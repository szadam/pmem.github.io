<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tiering on PMem.io</title><link>https://pmem.io/tags/tiering/</link><description>Recent content in tiering on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 29 Jun 2022 00:00:00 +0200</lastBuildDate><atom:link href="https://pmem.io/tags/tiering/index.xml" rel="self" type="application/rss+xml"/><item><title>Memory Tiering (part 2): Writing Transparent Tiering Solution</title><link>https://pmem.io/blog/2022/06/memory-tiering-part-2-writing-transparent-tiering-solution/</link><pubDate>Wed, 29 Jun 2022 00:00:00 +0200</pubDate><guid>https://pmem.io/blog/2022/06/memory-tiering-part-2-writing-transparent-tiering-solution/</guid><description>This is the second part of the series of articles about memory tiering. The first one explained what memory tiering is and why we need it, the second one will explain some mechanisms behind transparent tiering.
This article is intended for those who would like to learn how tiering/numa balancing or memory profiling solutions work under the hood. We will focus on a high-level overview of how tiering/numa balancing could be designed, instead of dissecting any particular solution.</description></item><item><title>Memory Tiering (part 1)</title><link>https://pmem.io/blog/2022/06/memory-tiering-part-1/</link><pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate><guid>https://pmem.io/blog/2022/06/memory-tiering-part-1/</guid><description>Extending memory capacity with PMEM Databases such as Redis (an in-memory key-value open-source database) consume a lot of memory. Since fast access is essential for them, they use DRAM to store their data. DRAM is quite expensive and has limited capacity, so a solution we propose in this blog post is to use PMEM (and in the future other types of memory available through CXL - see a pmem.io blog post about it).</description></item></channel></rss>