<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="libpmemstream"><meta property="og:description" content="NAME
SYNOPSIS
DESCRIPTION
SEE ALSO
NAME libpmemstream - a logging data structure optimized for persistent memory.
SYNOPSIS #include <libpmemstream.h> struct pmemstream; struct pmemstream_entry_iterator; struct pmemstream_region_iterator; struct pmemstream_region_runtime; struct pmemstream_region { uint64_t offset; }; struct pmemstream_entry { uint64_t offset; }; struct pmemstream_async_wait_data; struct pmemstream_async_wait_output { int error_code; }; FUTURE(pmemstream_async_wait_fut, struct pmemstream_async_wait_data, struct pmemstream_async_wait_output); int pmemstream_from_map(struct pmemstream **stream, size_t block_size, struct pmem2_map *map); void pmemstream_delete(struct pmemstream **stream); int pmemstream_region_allocate(struct pmemstream *stream, size_t size, struct pmemstream_region *region); int pmemstream_region_free(struct pmemstream *stream, struct pmemstream_region region); size_t pmemstream_region_size(struct pmemstream *stream, struct pmemstream_region region); size_t pmemstream_region_usable_size(struct pmemstream *stream, struct pmemstream_region region); int pmemstream_region_runtime_initialize(struct pmemstream *stream, struct pmemstream_region region, struct pmemstream_region_runtime **runtime); int pmemstream_reserve(struct pmemstream *stream, struct pmemstream_region region, struct pmemstream_region_runtime *region_runtime, size_t size, struct pmemstream_entry *reserved_entry, void **data); int pmemstream_publish(struct pmemstream *stream, struct pmemstream_region region, struct pmemstream_region_runtime *region_runtime, struct pmemstream_entry entry, size_t size); int pmemstream_append(struct pmemstream *stream, struct pmemstream_region region, struct pmemstream_region_runtime *region_runtime, const void *data, size_t size, struct pmemstream_entry *new_entry); int pmemstream_async_publish(struct pmemstream *stream, struct pmemstream_region region, struct pmemstream_region_runtime *region_runtime, struct pmemstream_entry entry, size_t size); int pmemstream_async_append(struct pmemstream *stream, struct vdm *vdm, struct pmemstream_region region, struct pmemstream_region_runtime *region_runtime, const void *data, size_t size, struct pmemstream_entry *new_entry); uint64_t pmemstream_committed_timestamp(struct pmemstream *stream); uint64_t pmemstream_persisted_timestamp(struct pmemstream *stream); struct pmemstream_async_wait_fut pmemstream_async_wait_committed(struct pmemstream *stream, uint64_t timestamp); struct pmemstream_async_wait_fut pmemstream_async_wait_persisted(struct pmemstream *stream, uint64_t timestamp); const void *pmemstream_entry_data(struct pmemstream *stream, struct pmemstream_entry entry); size_t pmemstream_entry_size(struct pmemstream *stream, struct pmemstream_entry entry); uint64_t pmemstream_entry_timestamp(struct pmemstream *stream, struct pmemstream_entry entry); int pmemstream_entry_iterator_new(struct pmemstream_entry_iterator **iterator, struct pmemstream *stream, struct pmemstream_region region); int pmemstream_entry_iterator_is_valid(struct pmemstream_entry_iterator *iterator); void pmemstream_entry_iterator_next(struct pmemstream_entry_iterator *iterator); void pmemstream_entry_iterator_seek_first(struct pmemstream_entry_iterator *iterator); struct pmemstream_entry pmemstream_entry_iterator_get(struct pmemstream_entry_iterator *iterator); void pmemstream_entry_iterator_delete(struct pmemstream_entry_iterator **iterator); int pmemstream_region_iterator_new(struct pmemstream_region_iterator **iterator, struct pmemstream *stream); int pmemstream_region_iterator_is_valid(struct pmemstream_region_iterator *iterator); void pmemstream_region_iterator_seek_first(struct pmemstream_region_iterator *iterator); void pmemstream_region_iterator_next(struct pmemstream_region_iterator *iterator); struct pmemstream_region pmemstream_region_iterator_get(struct pmemstream_region_iterator *iterator); void pmemstream_region_iterator_delete(struct pmemstream_region_iterator **iterator); DESCRIPTION Most of API functions are called with struct pmemstream *stream as a first argument."><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/pmemstream/manpages/master/libpmemstream.3/"><meta property="article:section" content="pmemstream"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>libpmemstream</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=page-title class="page-title-parallax page-title-center page-title-dark include-header skrollable skrollable-between" style="background-image:url('');background-size:cover;padding:120px 0;margin-top:-157.05px"><div class="container clearfix mt-4"><div class="slider-title text-light"><h2 style=color:#fff></h2></div></div></section><div class="section m-0 bg-transparent library-section dark-mode"><div class=container><div class="row justify-content-between"><div class="col mt-0 lib-content"><p><a href=#name>NAME</a><br><a href=#synopsis>SYNOPSIS</a><br><a href=#description>DESCRIPTION</a><br><a href=#see-also>SEE ALSO</a></p><h1 id=name>NAME</h1><p><strong>libpmemstream</strong> - a logging data structure optimized for persistent memory.</p><h1 id=synopsis>SYNOPSIS</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;libpmemstream.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmemstream;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmemstream_entry_iterator;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmemstream_region_iterator;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmemstream_region_runtime;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmemstream_region {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>uint64_t</span> offset;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmemstream_entry {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>uint64_t</span> offset;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmemstream_async_wait_data;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmemstream_async_wait_output {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> error_code;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FUTURE(pmemstream_async_wait_fut,
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> pmemstream_async_wait_data, <span style=color:#66d9ef>struct</span> pmemstream_async_wait_output);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmemstream_from_map</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>**</span>stream, size_t block_size, <span style=color:#66d9ef>struct</span> pmem2_map <span style=color:#f92672>*</span>map);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pmemstream_delete</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>**</span>stream);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmemstream_region_allocate</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, size_t size, <span style=color:#66d9ef>struct</span> pmemstream_region <span style=color:#f92672>*</span>region);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmemstream_region_free</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>struct</span> pmemstream_region region);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>size_t <span style=color:#a6e22e>pmemstream_region_size</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>struct</span> pmemstream_region region);
</span></span><span style=display:flex><span>size_t <span style=color:#a6e22e>pmemstream_region_usable_size</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>struct</span> pmemstream_region region);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmemstream_region_runtime_initialize</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>struct</span> pmemstream_region region,
</span></span><span style=display:flex><span>					 <span style=color:#66d9ef>struct</span> pmemstream_region_runtime <span style=color:#f92672>**</span>runtime);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmemstream_reserve</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>struct</span> pmemstream_region region,
</span></span><span style=display:flex><span>		       <span style=color:#66d9ef>struct</span> pmemstream_region_runtime <span style=color:#f92672>*</span>region_runtime, size_t size,
</span></span><span style=display:flex><span>		       <span style=color:#66d9ef>struct</span> pmemstream_entry <span style=color:#f92672>*</span>reserved_entry, <span style=color:#66d9ef>void</span> <span style=color:#f92672>**</span>data);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmemstream_publish</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>struct</span> pmemstream_region region,
</span></span><span style=display:flex><span>		       <span style=color:#66d9ef>struct</span> pmemstream_region_runtime <span style=color:#f92672>*</span>region_runtime, <span style=color:#66d9ef>struct</span> pmemstream_entry entry, size_t size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmemstream_append</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>struct</span> pmemstream_region region,
</span></span><span style=display:flex><span>		      <span style=color:#66d9ef>struct</span> pmemstream_region_runtime <span style=color:#f92672>*</span>region_runtime, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data, size_t size,
</span></span><span style=display:flex><span>		      <span style=color:#66d9ef>struct</span> pmemstream_entry <span style=color:#f92672>*</span>new_entry);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmemstream_async_publish</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>struct</span> pmemstream_region region,
</span></span><span style=display:flex><span>			     <span style=color:#66d9ef>struct</span> pmemstream_region_runtime <span style=color:#f92672>*</span>region_runtime, <span style=color:#66d9ef>struct</span> pmemstream_entry entry,
</span></span><span style=display:flex><span>			     size_t size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmemstream_async_append</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>struct</span> vdm <span style=color:#f92672>*</span>vdm, <span style=color:#66d9ef>struct</span> pmemstream_region region,
</span></span><span style=display:flex><span>			    <span style=color:#66d9ef>struct</span> pmemstream_region_runtime <span style=color:#f92672>*</span>region_runtime, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data, size_t size,
</span></span><span style=display:flex><span>			    <span style=color:#66d9ef>struct</span> pmemstream_entry <span style=color:#f92672>*</span>new_entry);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint64_t</span> <span style=color:#a6e22e>pmemstream_committed_timestamp</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream);
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint64_t</span> <span style=color:#a6e22e>pmemstream_persisted_timestamp</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmemstream_async_wait_fut <span style=color:#a6e22e>pmemstream_async_wait_committed</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>uint64_t</span> timestamp);
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmemstream_async_wait_fut <span style=color:#a6e22e>pmemstream_async_wait_persisted</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>uint64_t</span> timestamp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>pmemstream_entry_data</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>struct</span> pmemstream_entry entry);
</span></span><span style=display:flex><span>size_t <span style=color:#a6e22e>pmemstream_entry_size</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>struct</span> pmemstream_entry entry);
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint64_t</span> <span style=color:#a6e22e>pmemstream_entry_timestamp</span>(<span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>struct</span> pmemstream_entry entry);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmemstream_entry_iterator_new</span>(<span style=color:#66d9ef>struct</span> pmemstream_entry_iterator <span style=color:#f92672>**</span>iterator, <span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream,
</span></span><span style=display:flex><span>				  <span style=color:#66d9ef>struct</span> pmemstream_region region);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmemstream_entry_iterator_is_valid</span>(<span style=color:#66d9ef>struct</span> pmemstream_entry_iterator <span style=color:#f92672>*</span>iterator);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pmemstream_entry_iterator_next</span>(<span style=color:#66d9ef>struct</span> pmemstream_entry_iterator <span style=color:#f92672>*</span>iterator);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pmemstream_entry_iterator_seek_first</span>(<span style=color:#66d9ef>struct</span> pmemstream_entry_iterator <span style=color:#f92672>*</span>iterator);
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmemstream_entry <span style=color:#a6e22e>pmemstream_entry_iterator_get</span>(<span style=color:#66d9ef>struct</span> pmemstream_entry_iterator <span style=color:#f92672>*</span>iterator);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pmemstream_entry_iterator_delete</span>(<span style=color:#66d9ef>struct</span> pmemstream_entry_iterator <span style=color:#f92672>**</span>iterator);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmemstream_region_iterator_new</span>(<span style=color:#66d9ef>struct</span> pmemstream_region_iterator <span style=color:#f92672>**</span>iterator, <span style=color:#66d9ef>struct</span> pmemstream <span style=color:#f92672>*</span>stream);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pmemstream_region_iterator_is_valid</span>(<span style=color:#66d9ef>struct</span> pmemstream_region_iterator <span style=color:#f92672>*</span>iterator);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pmemstream_region_iterator_seek_first</span>(<span style=color:#66d9ef>struct</span> pmemstream_region_iterator <span style=color:#f92672>*</span>iterator);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pmemstream_region_iterator_next</span>(<span style=color:#66d9ef>struct</span> pmemstream_region_iterator <span style=color:#f92672>*</span>iterator);
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> pmemstream_region <span style=color:#a6e22e>pmemstream_region_iterator_get</span>(<span style=color:#66d9ef>struct</span> pmemstream_region_iterator <span style=color:#f92672>*</span>iterator);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pmemstream_region_iterator_delete</span>(<span style=color:#66d9ef>struct</span> pmemstream_region_iterator <span style=color:#f92672>**</span>iterator);
</span></span></code></pre></div><h1 id=description>DESCRIPTION</h1><p>Most of API functions are called with <code>struct pmemstream *stream</code> as a first argument. It is a structure
representing runtime state of a single <em>pmemstream</em> instance. It has to be a pointer to a valid
<em>pmemstream</em> instance, created/opened using <code>pmemstream_from_map</code> call.</p><p>When it comes to iterator-related API - first parameter in these functions is usually
<code>struct pmemstream_region_iterator *iterator</code> or <code>struct pmemstream_entry_iterator *iterator</code>.
These structures represent <em>region</em> and <em>entry</em> iterators and should be created using appropriate <em>new</em> functions:
<code>pmemstream_region_iterator_new</code> or <code>pmemstream_entry_iterator_new</code>. In both these functions <code>stream</code> parameter
is passed to iterator, so such iterator is bound to a selected pmemstream instance and it&rsquo;s not required
to pass it along to other iterator-related functions.</p><p>For high level description of pmemstream or its features/functionalities please see <strong>libpmemstream</strong>(7).
For detailed description of a specific function and its parameters see below.</p><dl><dt><code>int pmemstream_from_map(struct pmemstream **stream, size_t block_size, struct pmem2_map *map);</code></dt><dd><p>Creates new pmemstream instance from the given <em>pmem2_map</em> <code>map</code> and assigns it to <code>stream</code> pointer.
<code>block_size</code> defines alignment of regions - must be a power of 2 and multiple of CACHELINE size.
See <strong>libpmem2</strong>(7) for details on creating pmem2 mapping.
If this function is called with a map representing an empty file, the new pmemstream instance will be initialized.
If a mapping points to a previously existing pmemstream instance, it re-opens it and reads persisted header&rsquo;s data.
In any other case, it&rsquo;s undefined behavior.
It returns 0 on success, error code otherwise.</p></dd><dt><code>void pmemstream_delete(struct pmemstream **stream);</code></dt><dd><p>Releases the given &lsquo;stream&rsquo; resources and sets &lsquo;stream&rsquo; pointer to NULL.</p></dd><dt><code>int pmemstream_region_allocate(struct pmemstream *stream, size_t size, struct pmemstream_region *region);</code></dt><dd><p>Allocates new region with specified &lsquo;size&rsquo;. Actual size might be bigger due to alignment requirements.
Only fixed-sized regions are supported for now (all <code>pmemstream_region_allocate</code> calls within a single
pmemstream instance have to use the same size).
Optional &lsquo;region&rsquo; parameter is updated with the new region information.
It returns 0 on success, error code otherwise.</p></dd><dt><code>int pmemstream_region_free(struct pmemstream *stream, struct pmemstream_region region);</code></dt><dd><p>Frees previously allocated, specified &lsquo;region&rsquo;.
It returns 0 on success, error code otherwise.</p></dd><dt><code>size_t pmemstream_region_size(struct pmemstream *stream, struct pmemstream_region region);</code></dt><dd><p>Returns size of the given &lsquo;region&rsquo;. It may be bigger than the size passed to &lsquo;pmemstream_region_allocate&rsquo;
due to an alignment.
On error returns 0.</p></dd><dt><code>size_t pmemstream_region_usable_size(struct pmemstream *stream, struct pmemstream_region region);</code></dt><dd><p>Returns current usable (free) size of the given &lsquo;region&rsquo;.
It equals to: &lsquo;region&rsquo;s end offset&rsquo; - &lsquo;region&rsquo;s append offset&rsquo;.
This function serves only as an approximation of available space for use.
See <code>pmemstream_entry_size</code> to read more about space used by entries.
On error returns 0.</p></dd><dt><code>int pmemstream_region_runtime_initialize(struct pmemstream *stream, struct pmemstream_region region, struct pmemstream_region_runtime **runtime);</code></dt><dd><p>Initializes pmemstream_region_runtime for the given &lsquo;region&rsquo;. The runtime holds current, runtime
data (like append_offset) for a region. The runtime is managed by libpmemstream - user does not have
to explicitly delete/free it. Runtime becomes invalid after corresponding region is freed.
Pointer to initialized pmemstream_region_runtime is returned via &lsquo;runtime&rsquo; parameter.
Call to this function might be expensive. If it is not called explicitly, pmemstream will call it
inside a first append/reserve in a region.
Returns 0 on success, error code otherwise.</p></dd><dt><code>int pmemstream_reserve(struct pmemstream *stream, struct pmemstream_region region, struct pmemstream_region_runtime *region_runtime, size_t size, struct pmemstream_entry *reserved_entry, void **data);</code></dt><dd><p>Reserves space (for a future, custom write) of the given &lsquo;size&rsquo;, in a &lsquo;region&rsquo; at offset determined
by &lsquo;region_runtime&rsquo;. Entry&rsquo;s data have to be copied into reserved space by the user and then published
using pmemstream_publish. This approach is only recommended for special use cases, e.g. custom memcpy
or use with C++ &ldquo;placement new&rdquo; syntax.
For regular usage, pmemstream_append should be simpler and safer to use and provide better performance.
&lsquo;region_runtime&rsquo; is an optional parameter which can be obtained from pmemstream_region_runtime_initialize.
If it&rsquo;s NULL, it will be obtained from its internal structures (which might incur overhead).
&lsquo;reserved_entry&rsquo; is updated with an offset of the reserved entry - this entry has to be passed to
pmemstream_publish for completing the custom append process.
&lsquo;data&rsquo; is updated with a pointer to reserved space - this is a destination for, e.g., custom memcpy.
It is not allowed to call pmemstream_reserve for the second time before calling pmemstream_publish.
It returns 0 on success, error code otherwise.</p></dd><dt><code>int pmemstream_publish(struct pmemstream *stream, struct pmemstream_region region, struct pmemstream_region_runtime *region_runtime, struct pmemstream_entry entry, size_t size);</code></dt><dd><p>Synchronously publishes previously custom-written &rsquo;entry&rsquo; in a &lsquo;region&rsquo;.
After calling pmemstream_reserve and writing/memcpy&rsquo;ing data into a reserved_entry, it&rsquo;s required
to call this function for setting proper entry&rsquo;s metadata and persist the data.
&lsquo;region_runtime&rsquo; is an optional parameter which can be obtained from pmemstream_region_runtime_initialize.
If it&rsquo;s NULL, it will be obtained from its internal structures (which might incur overhead).
&lsquo;size&rsquo; of the entry has to match the previous reservation and the actual size of the data written by user.
It returns 0 on success, error code otherwise.</p></dd><dt><code>int pmemstream_append(struct pmemstream *stream, struct pmemstream_region region, struct pmemstream_region_runtime *region_runtime, const void *data, size_t size, struct pmemstream_entry *new_entry);</code></dt><dd><p>Synchronously appends data buffer to a given region, at offset determined by region_runtime.
Fails if no space is available.
&lsquo;region_runtime&rsquo; is an optional parameter which can be obtained from pmemstream_region_runtime_initialize.
If it&rsquo;s NULL, it will be obtained from its internal structures (which might incur overhead).
&lsquo;data&rsquo; is a pointer to the data buffer, to be appended.
&lsquo;size&rsquo; is the size of the data buffer, to be appended.
&rsquo;new_entry&rsquo; is an optional pointer. On success, it will contain information about newly appended entry
(with its offset within pmemstream).
It returns 0 on success, error code otherwise.</p></dd><dt><code>int pmemstream_async_publish(struct pmemstream *stream, struct pmemstream_region region, struct pmemstream_region_runtime *region_runtime, struct pmemstream_entry entry, size_t size);</code></dt><dd><p>Asynchronous version of pmemstream_publish.
It publishes previously custom-written entry. &rsquo;entry&rsquo; is marked as ready for commit.
There is no guarantee whether data is visible by iterators or persisted after this call.
To commit (and make the data visible to iterators) or persist the data use: pmemstream_async_wait_committed or
pmemstream_async_wait_persisted.
It returns 0 on success, error code otherwise.</p></dd><dt><code>int pmemstream_async_append(struct pmemstream *stream, struct vdm *vdm, struct pmemstream_region region, struct pmemstream_region_runtime *region_runtime, const void *data, size_t size, struct pmemstream_entry *new_entry);</code></dt><dd><p>Asynchronous version of pmemstream_append.
It appends &lsquo;data&rsquo; to the region and marks it as ready for commit.
There is no guarantee whether data is visible by iterators or persisted after this call.
To commit (and make the data visible to iterators) or persist the data use: pmemstream_async_wait_committed or
pmemstream_async_wait_persisted and poll returned future to completion.
It returns 0 on success, error code otherwise.</p></dd><dt><code>uint64_t pmemstream_committed_timestamp(struct pmemstream *stream);</code></dt><dd><p>Returns the most recent committed timestamp in the given stream. All entries with timestamps less than or equal to
that timestamp can be treated as committed.
On error it returns invalid timestamp (a special flag properly handled in all functions using timestamps).</p></dd><dt><code>uint64_t pmemstream_persisted_timestamp(struct pmemstream *stream);</code></dt><dd><p>Returns the most recent persisted timestamp in the given stream. All entries with timestamps less than or equal to
that timestamp can be treated as persisted.
It is guaranteed to be less than or equal to committed timestamp.
On error it returns invalid timestamp (a special flag properly handled in all functions using timestamps).</p></dd><dt><code>struct pmemstream_async_wait_fut pmemstream_async_wait_committed(struct pmemstream *stream, uint64_t timestamp);</code></dt><dd><p>Returns future for committing all entries up to specified &rsquo;timestamp&rsquo;.
To get &ldquo;committed&rdquo; guarantee for given &rsquo;timestamp&rsquo;, the returned future must be polled until completion.
Data which is committed, but not yet persisted, will be visible for iterators but might not be reachable after
application&rsquo;s restart.
When returned future is polled to completion, it&rsquo;s best to check its output field <code>error_code</code>
(see: <code>struct pmemstream_async_wait_output</code>) for any non-zero returned value.</p></dd><dt><code>struct pmemstream_async_wait_fut pmemstream_async_wait_persisted(struct pmemstream *stream, uint64_t timestamp);</code></dt><dd><p>Returns future for persisting all entries up to specified &rsquo;timestamp&rsquo;.
To get &ldquo;persisted&rdquo; guarantee for given &rsquo;timestamp&rsquo;, the returned future must be polled until completion.
Persisted data is guaranteed to be reachable after application&rsquo;s restart.
If entry is persisted, it is also guaranteed to be committed.
When returned future is polled to completion, it&rsquo;s best to check its output field <code>error_code</code>
(see: <code>struct pmemstream_async_wait_output</code>) for any non-zero returned value.</p></dd><dt><code>const void *pmemstream_entry_data(struct pmemstream *stream, struct pmemstream_entry entry);</code></dt><dd><p>Returns pointer to the data of the given &rsquo;entry&rsquo; (if it points to a valid entry).
On error returns NULL.</p></dd><dt><code>size_t pmemstream_entry_size(struct pmemstream *stream, struct pmemstream_entry entry);</code></dt><dd><p>Returns the size of the data of given &rsquo;entry&rsquo;. It&rsquo;s the same value as was passed to <code>pmemstream_append</code>.
Note that pmemstream_entry contains metadata along with appended data - the space occupied
by pmemstream_entry is actually bigger than the size of appended data.
It returns 0, if &rsquo;entry&rsquo; does not point to a valid entry or error occurred.</p></dd><dt><code>uint64_t pmemstream_entry_timestamp(struct pmemstream *stream, struct pmemstream_entry entry);</code></dt><dd><p>Returns timestamp related to the given &rsquo;entry&rsquo; (if it points to a valid entry).
On error returns invalid timestamp (a special flag properly handled in all functions using timestamps).</p></dd><dt><code>int pmemstream_region_iterator_new(struct pmemstream_region_iterator **iterator, struct pmemstream *stream);</code></dt><dd><p>Creates a new pmemstream_region_iterator and assigns it to &lsquo;iterator&rsquo; pointer.
Such iterator is bound to the given &lsquo;stream&rsquo;.
Default state is undefined: every new iterator should be moved (e.g.) to first element in the stream.
Returns 0 on success, and error code otherwise.</p></dd><dt><code>int pmemstream_region_iterator_is_valid(struct pmemstream_region_iterator *iterator);</code></dt><dd><p>Checks if given region &lsquo;iterator&rsquo; is in valid state.
Returns 0 when iterator is valid, and error code otherwise.</p></dd><dt><code>void pmemstream_region_iterator_seek_first(struct pmemstream_region_iterator *iterator);</code></dt><dd><p>Sets region &lsquo;iterator&rsquo; to the first region (if such region exists), or sets iterator to invalid region.</p></dd><dt><code>void pmemstream_region_iterator_next(struct pmemstream_region_iterator *iterator);</code></dt><dd><p>Moves region &lsquo;iterator&rsquo; to next region (if any more exists), or sets iterator to invalid region.
Regions are accessed in the order of allocations.
Calling this function on iterator pointing to an invalid region is undefined behavior.
It should always be called after <code>pmemstream_region_iterator_is_valid()</code>.</p><pre tabindex=0><code>	if(pmemstream_region_iterator_is_valid(it) == 0)
		pmemstream_region_iterator_next(it);
</code></pre></dd><dt><code>struct pmemstream_region pmemstream_region_iterator_get(struct pmemstream_region_iterator *iterator);</code></dt><dd><p>Gets region from the given region &lsquo;iterator&rsquo;.
If the given iterator is valid, it returns a region pointed by it,
otherwise it returns an invalid region.</p></dd><dt><code>void pmemstream_region_iterator_delete(struct pmemstream_region_iterator **iterator);</code></dt><dd><p>Releases the given &lsquo;iterator&rsquo; resources and sets &lsquo;iterator&rsquo; pointer to NULL.</p></dd><dt><code>int pmemstream_entry_iterator_new(struct pmemstream_entry_iterator **iterator, struct pmemstream *stream, struct pmemstream_region region);</code></dt><dd><p>Creates a new pmemstream_entry_iterator for given &lsquo;region&rsquo; and assigns it to &lsquo;iterator&rsquo; pointer.
Entry iterator will iterate over all committed (but not necessarily persisted) entries within the region.
The entry iterator is bound to the given &lsquo;stream&rsquo; and &lsquo;region&rsquo;.
Default state is undefined: every new iterator should be moved (e.g.) to first element in the region.
Returns 0 on success, and error code otherwise.</p></dd><dt><code>int pmemstream_entry_iterator_is_valid(struct pmemstream_entry_iterator *iterator);</code></dt><dd><p>Checks that entry &lsquo;iterator&rsquo; is in valid state.
Returns 0 when iterator is valid, and error code otherwise.</p></dd><dt><code>void pmemstream_entry_iterator_seek_first(struct pmemstream_entry_iterator *iterator);</code></dt><dd><p>Sets entry &lsquo;iterator&rsquo; to the first entry in the region (if such entry exists),
or sets iterator to invalid entry.</p></dd><dt><code>void pmemstream_entry_iterator_next(struct pmemstream_entry_iterator *iterator);</code></dt><dd><p>Moves entry &lsquo;iterator&rsquo; to next entry if possible.
It iterates over all committed (but not necessarily persisted) entries. They are accessed
in the order of appending (which is always linear). Note: entries cannot be removed from the stream,
with exception of removing the whole region.
Calling this function on iterator pointing to an invalid entry is undefined behavior.
It should always be called after <code>pmemstream_entry_iterator_is_valid()</code>.</p><pre tabindex=0><code>if(pmemstream_entry_iterator_is_valid(it) == 0)
	pmemstream_entry_iterator_next(it);
</code></pre></dd><dt><code>struct pmemstream_entry pmemstream_entry_iterator_get(struct pmemstream_entry_iterator *iterator);</code></dt><dd><p>Gets entry from the given entry &lsquo;iterator&rsquo;.
If the given iterator is valid, it returns an entry pointed by it,
otherwise it returns an invalid entry.</p></dd><dt><code>void pmemstream_entry_iterator_delete(struct pmemstream_entry_iterator **iterator);</code></dt><dd><p>Releases the given &lsquo;iterator&rsquo; resources and sets &lsquo;iterator&rsquo; pointer to NULL.</p></dd></dl><h1 id=see-also>SEE ALSO</h1><p><strong>libpmemstream</strong>(7), <strong>libpmem2</strong>(7), <strong>miniasync</strong>(7), and <strong><a href=https://pmem.io/pmemstream>https://pmem.io/pmemstream</a></strong></p></div></div><div class=divider></div><p class=text-center><small>The contents of this web site and the associated <a href=https://github.com/pmem>GitHub repositories</a> are BSD-licensed open source.</small></p></div></div><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2022 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>