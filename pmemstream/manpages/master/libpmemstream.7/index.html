<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="libpmemstream"><meta property="og:description" content="Table of Contents NAME
SYNOPSIS
DESCRIPTION
KNOWN CONSTRAINTS
USE CASES
DETAILED DESCRIPTIONS
APPENDING DATA METHODS
TIMESTAMPS
ASYNC API
ITERATORS
EXAMPLES
SEE ALSO
NAME libpmemstream - a logging data structure optimized for persistent memory.
SYNOPSIS #include <libpmemstream.h> cc ... -lpmemstream DESCRIPTION Libpmemstream implements a pmem-optimized log data structure and provides stream-like access to data. It presents a contiguous logical address space, divided into regions, with log entries of arbitrary size. It delivers a generic, easy-to-use, well-tested set of functions."><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/pmemstream/manpages/master/libpmemstream.7/"><meta property="article:section" content="pmemstream"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>libpmemstream</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=page-title class="page-title-parallax page-title-center page-title-dark include-header skrollable skrollable-between" style="background-image:url('');background-size:cover;padding:120px 0;margin-top:-157.05px"><div class="container clearfix mt-4"><div class="slider-title text-light"><h2 style=color:#fff></h2></div></div></section><div class="section m-0 bg-transparent library-section dark-mode"><div class=container><div class="row justify-content-between"><div class="col mt-0 lib-content"><h1 id=table-of-contents>Table of Contents</h1><p><a href=#name>NAME</a><br><a href=#synopsis>SYNOPSIS</a><br><a href=#description>DESCRIPTION</a><br><a href=#known-constraints>KNOWN CONSTRAINTS</a><br><a href=#use-cases>USE CASES</a><br><a href=#detailed-descriptions>DETAILED DESCRIPTIONS</a><br><a href=#appending-data-methods>APPENDING DATA METHODS</a><br><a href=#timestamps>TIMESTAMPS</a><br><a href=#async-api>ASYNC API</a><br><a href=#iterators>ITERATORS</a><br><a href=#examples>EXAMPLES</a><br><a href=#see-also>SEE ALSO</a></p><h1 id=name>NAME</h1><p><strong>libpmemstream</strong> - a logging data structure optimized for persistent memory.</p><h1 id=synopsis>SYNOPSIS</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;libpmemstream.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cc ... <span style=color:#f92672>-</span>lpmemstream
</span></span></code></pre></div><h1 id=description>DESCRIPTION</h1><p>Libpmemstream implements a pmem-optimized log data structure and provides stream-like access
to data. It presents a contiguous logical address space, divided into regions, with log entries
of arbitrary size. It delivers a generic, easy-to-use, well-tested set of functions. This library
may be a foundation for various, more complex, higher-level solutions (see <a href=#use-cases>Use Cases section below</a>).
It uses <strong>libpmem2</strong>(7) and <strong>libminiasync</strong>(7) underneath - the second one specifically for asynchronous API.</p><p>Up-to-date information about this library can always be found on
<a href=https://github.com/pmem/pmemstream>GitHub repository page</a>.</p><p>Libpmemstream is a successor for <strong>libpmemlog</strong>(7). These two libraries are very similar in basic concept,
but libpmemlog was developed in a straightforward manner and does not allow easy extensions.
That&rsquo;s why this library is designed from scratch to enable more advanced features.</p><p>Core features:</p><ul><li>pmemstream may contain multiple regions,</li><li>new data entries are appended at the end (of a selected region),</li><li>each entry may be of arbitrary size,</li><li>each entry append is atomic (there&rsquo;re no data consistency issues),</li><li>alternative API (to regular <code>append</code>) - <code>reserve</code> + <code>publish</code>, to allow custom writing
(memcpy-ing) entry&rsquo;s data (see <a href=#examples>Examples section below</a>),</li><li>asynchronous (additional to synchronous) API for appending,</li><li>multiple threads can append data concurrently (only to different regions - see below!),</li><li>entry_iterator allows reading data in sequence (within a region),</li><li>each entry is marked with timestamp, to provide global entries&rsquo; order (and easier recovery).</li></ul><p>Some of these features are described in more details below.</p><h2 id=known-constraints>KNOWN CONSTRAINTS</h2><blockquote><p>This is experimental pre-release software and should not be used in production systems.
APIs and file formats may change at any time without preserving backwards compatibility.
All known issues and limitations are logged as GitHub issues.</p></blockquote><p>There are few relevant constraints, we&rsquo;re aware of (some are only temporary and will be
fixed in future releases):</p><ul><li>region allocator is constrained with a single allocation size - first region allocated in a stream
defines the size for other regions within that stream,</li><li>no entry modification or removal allowed (the only way to remove an entry is by removing the region containing it),</li><li>as stated above - multiple threads can append data concurrently, but only to different regions.
No two threads can append to the same region (concurrently),</li><li>most functions return (on error) generic <code>-1</code> value, instead of more specific error codes
(see specific function&rsquo;s description for details of returned type and values),</li><li>there&rsquo;s a limited number of slots for concurrent operations - currently, only 1024 operations can be
processed in the stream at any given moment. When all slots are taken, a thread has to wait for
some of the previous operations to finish.</li></ul><h2 id=use-cases>USE CASES</h2><p>This library is meant to provide a flexible implementation of stream/log structure so it could be used
in many different solutions. Example use cases are:</p><ul><li>persistent double-write buffer in databases,</li><li>persistent level in LSM tree implementations,</li><li>a base for any copy-on-write data structure,</li><li>transactional undo or redo logs, like in <strong>libpmemobj</strong>(7),</li><li>PMEM-buffered file I/O primitives that offload to a slower medium,
and many, many more.</li></ul><h2 id=detailed-descriptions>DETAILED DESCRIPTIONS</h2><p>Some of the internal features/functionalities require an additional explanation. We recommend reading this section
to better understand how pmemstream works.</p><h3 id=appending-data-methods>APPENDING DATA METHODS</h3><p>Libpmemstream&rsquo;s main operation is an append. We support that in a few various ways:</p><ol><li>&ldquo;regular&rdquo;, synchronous append with <code>pmemstream_append</code>,</li><li>asynchronous append with <code>pmemstream_async_append</code>,</li><li>reserve + custom write + publish approach, using <code>pmemstream_reserve</code> and <code>pmemstream_publish</code>,</li><li>asynchronous variant of reserve-publish, with <code>pmemstream_async_publish</code>.</li></ol><p>While the most natural and the easiest way of appending data to the stream is option number one above,
we introduced other approaches for specific users&rsquo; needs.</p><p>An asynchronous approach (either with async_append or just async_publish) may be a little bit complicated
but gives users more flexibility. For a description of how to properly handle asynchronous appends, see
<a href=#async-api>Async API section below</a>.</p><p>See <a href=#examples>examples section below</a> for a pointer where to look for sample pieces of code.
There are various examples showing, i.a., how asynchronous API works or how to best apply the reserve-publish
approach in a user&rsquo;s application.</p><h3 id=timestamps>TIMESTAMPS</h3><p>Timestamps were introduced in version 0.2.0. Each entry is always persistently marked with a unique, monotonically
increasing number - a <strong>timestamp</strong>. Timestamps provide global entries&rsquo; ordering. It means it&rsquo;s possible to append
entries to different regions within a single stream and still be able to read them out in a global (stream&rsquo;s)
sequence. It&rsquo;s possible to read out the timestamp of a given entry using <code>pmemstream_entry_timestamp</code>.</p><p>In case of an application crash, power failure, or just a restart, timestamps are used for recovery. Every entry
with a timestamp lower than or equal to a <strong>persisted_timestamp</strong> will be treated as properly stored on the underlying
medium. There are two functions returning the most recently committed/persisted timestamp within the stream.
Accordingly, these are: <code>pmemstream_committed_timestamp</code> and <code>pmemstream_persisted_timestamp</code>.</p><h3 id=async-api>ASYNC API</h3><p>Asynchronous API was also introduced in version 0.2.0. It makes use of <a href=https://github.com/pmem/miniasync>miniasync library</a>.
It&rsquo;s an extension to synchronous API. <code>pmemstream_append</code> and <code>pmemstream_publish</code> have their async
counterparts: <code>pmemstream_async_append</code> and <code>pmemstream_async_publish</code>. Note: <code>pmemstream_reserve</code> does not
require one since it&rsquo;s always an immediate operation - it only reserves an internal offset for the upcoming entry.
With asynchronous appends, we introduced two defined stages an append can be in: <strong>committed</strong> or <strong>persisted</strong>.
The third stage an append can be in, is &ldquo;in progress&rdquo; (may be treated as an undefined stage - we don&rsquo;t know yet if
the append has finished). <strong>Committed</strong> (but not yet persisted) data will be visible for iterators,
but it might not be reachable after the application restart. <strong>Persisted</strong> data, on the other hand, is guaranteed to
be committed and will be reachable after the application&rsquo;s restart. When an asynchronous append is started,
we don&rsquo;t know when exactly it ends. To solve that problem, there are dedicated (also asynchronous) functions:
<code>pmemstream_async_wait_committed</code> and <code>pmemstream_async_wait_persisted</code>. They both take a <strong>timestamp</strong> as an argument.
These two functions allow us to wait (and make progress towards) for a specified entry with a given timestamp,
to be either available for reading or to be guaranteed persistent.</p><p><code>pmemstream_async_wait_committed</code> and <code>pmemstream_async_wait_persisted</code> return <code>struct pmemstream_async_wait_fut</code>,
which is a miniasync&rsquo;s <strong>future</strong>. It&rsquo;s a concept representing a task (or tasks) that can be executed incrementally
by polling until the operation is complete. For detailed information on using miniasync library and <code>future</code> type see
<strong>miniasync_future</strong>(7). In libpmemstream, the important part is that the user has to poll a returned future until
completion. It&rsquo;s worth noticing that, even though <code>pmemstream_async_append</code> is asynchronous, it does not return a
<strong>future</strong>. The user&rsquo;s only option to actually execute started appends is by calling any of the
<code>pmemstream_async_wait_*</code> functions. Without that, they may be indefinitely &ldquo;in progress&rdquo; and never finish (meaning,
they never be either committed or persisted).</p><p>With asynchronous API and usage of Miniasync, there comes an additional benefit. (Virtual) Data Mover abstraction
enables users to take advantage of parallel execution thanks to optimized threaded-based implementations
as well as hardware accelerators (like DSA). Using such an accelerator is possible, e.g., with the implementation of
<strong>DML</strong> data mover API in Miniasync (see <strong>miniasync_vdm_dml</strong>(7) for more details). To read more about DSA and see
possible use cases or benefits, you can look at <a href=https://pmem.io/tags/dsa>our blog posts regarding this topic</a>.</p><h3 id=iterators>ITERATORS</h3><p>Operating on data within libpmemstream, means operating on entries located in regions. To iterate over all entries
or regions there&rsquo;s a special set of functions.</p><p>Firstly, a user may want to list all regions within the stream. There&rsquo;s a dedicated <code>struct pmemstream_region_iterator</code>
representing a region&rsquo;s iterator and a family of functions related to that API, all prefixed with:
<code>pmemstream_region_iterator_</code>. To create a new iterator user have to call <code>pmemstream_region_iterator_new</code>.
Initially, a user should call <code>pmemstream_region_iterator_seek_first</code> to move the iterator onto the first region.
Before reading the region pointed by the iterator, it is required to check if the iterator is at a
valid position: <code>pmemstream_region_iterator_is_valid</code>. If the iterator is valid, a user may safely get a
<code>struct pmemstream_region</code> using <code>pmemstream_region_iterator_get</code>. When a user wants to go to next region,
it is required to call <code>pmemstream_region_iterator_next</code>. It&rsquo;s worth noticing here that regions are iterated in the
order of their creation. It&rsquo;s important because regions are allowed to be removed (using <code>pmemstream_region_free</code>).
When the iterator is no longer needed (or when a user wants to close the application), it is required
to call <code>pmemstream_region_iterator_delete</code>, to free iterator&rsquo;s structure resources.</p><p>An iterator for browsing through all entries within a selected region - <code>struct pmemstream_entry_iterator</code> behaves
very similarly. The sequence of steps is alike: <strong>new iterator</strong>, <strong>seek (first)</strong>, <strong>next</strong>/<strong>get</strong> and finally
<strong>delete</strong>. The API related to the entry iterator is always prefixed with <code>pmemstream_entry_iterator_</code>.
The main difference for this iterator is that it returns <code>struct pmemstream_entry</code> when <code>pmemstream_entry_iterator_get</code> is called.
Since pmemstream does not support removing a single entry and append always places new entries at the end,
entries within a region are also iterated in the order of their creation (which happens to be linear).</p><p>It&rsquo;s important to note, for both iterators, that calling <code>_next</code>, <code>_seek*</code> or <code>_get</code> on an invalid iterator
is undefined behavior.</p><h1 id=examples>EXAMPLES</h1><p>See <a href=https://github.com/pmem/pmemstream/tree/master/examples>examples dir on our GitHub</a>
for libpmemstream API usage.</p><h1 id=see-also>SEE ALSO</h1><p><strong>libpmem2</strong>(7), <strong>miniasync</strong>(7), <strong>libpmemlog</strong>(7), <strong>libpmemstream</strong>(3), and <strong><a href=https://pmem.io/pmemstream>https://pmem.io/pmemstream</a></strong></p></div></div><div class=divider></div><p class=text-center><small>The contents of this web site and the associated <a href=https://github.com/pmem>GitHub repositories</a> are BSD-licensed open source.</small></p></div></div><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2022 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>