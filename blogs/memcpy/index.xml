<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>memcpy on PMem.io</title><link>https://pmem.io/blogs/memcpy/</link><description>Recent content in memcpy on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 22 Jan 2019 19:55:17 -0700</lastBuildDate><atom:link href="https://pmem.io/blogs/memcpy/index.xml" rel="self" type="application/rss+xml"/><item><title>Extended memcpy in PMDK 1.5</title><link>https://pmem.io/blog/2019/01/extended-memcpy-in-pmdk-1.5/</link><pubDate>Tue, 22 Jan 2019 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2019/01/extended-memcpy-in-pmdk-1.5/</guid><description>In PMDK 1.5 we added new APIs for bulk persistent memory modifications. In short, we did this to:
give applications the ability to perform low-level performance optimizations clean up the naming scheme In order to understand what exactly and why we did that, let&amp;rsquo;s review the old API. In PMDK 1.4 we had these functions:
void *pmem_memmove_persist(void *pmemdest, const void *src, size_t len); void *pmem_memcpy_persist (void *pmemdest, const void *src, size_t len); void *pmem_memset_persist (void *pmemdest, int c, size_t len); void *pmem_memmove_nodrain(void *pmemdest, const void *src, size_t len); void *pmem_memcpy_nodrain (void *pmemdest, const void *src, size_t len); void *pmem_memset_nodrain (void *pmemdest, int c, size_t len); void *pmemobj_memcpy_persist(PMEMobjpool *pop, void *pmemdest, const void *src, size_t len); void *pmemobj_memset_persist(PMEMobjpool *pop, void *pmemdest, int c, size_t len); As you can see, there are two variants of each API - one with _persist and another one with _nodrain suffix.</description></item></channel></rss>