<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>libpmemobj on PMem.io</title><link>https://pmem.io/blogs/libpmemobj/</link><description>Recent content in libpmemobj on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 23 Jan 2017 19:55:17 -0700</lastBuildDate><atom:link href="https://pmem.io/blogs/libpmemobj/index.xml" rel="self" type="application/rss+xml"/><item><title>Modeling strings with libpmemobj C++ bindings</title><link>https://pmem.io/blog/2017/01/modeling-strings-with-libpmemobj-c-bindings/</link><pubDate>Mon, 23 Jan 2017 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2017/01/modeling-strings-with-libpmemobj-c-bindings/</guid><description>C++ developers using libpmemobj have more than one option for modeling strings, depending on the size of the strings and whether they are fixed or varying in length. In this post we&amp;rsquo;ll review the representations that work, known variations to avoid, and finally present a persistent string class that implements these best practices.
Avoid wrapping fixed-size arrays You might expect (like I did at first!) that p&amp;lt;char[size]&amp;gt; is a proper way to simply model a fixed-size string, but actually this is not correct.</description></item><item><title>libpmemobj - a year in review</title><link>https://pmem.io/blog/2016/12/libpmemobj-a-year-in-review/</link><pubDate>Tue, 20 Dec 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/12/libpmemobj-a-year-in-review/</guid><description>It&amp;rsquo;s been a while since the last post on our blog, but we&amp;rsquo;ve been busy with the recently released 1.2 version of the library. It comes packed with improvements all throughout the code base and it also brings a handful of new features that we hope will end up being useful.
With the year coming to an end, it&amp;rsquo;s a good time to look back and discuss the things we&amp;rsquo;ve learned and accomplished.</description></item><item><title>C++ bindings for libpmemobj (epilogue) - converting existing applications</title><link>https://pmem.io/blog/2016/06/c-bindings-for-libpmemobj-epilogue-converting-existing-applications/</link><pubDate>Thu, 02 Jun 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/06/c-bindings-for-libpmemobj-epilogue-converting-existing-applications/</guid><description>During the development of the C++ bindings, we wrote a couple of examples and even more tests. But these are new applications written from scratch to understand persistence. While this approach is OK for newly developed apps, there is a lot of existing code out there that is not designed for persistent memory. It would be a real shame, if the existing solutions couldn&amp;rsquo;t benefit from the existence of persistent memory because of the amount of work needed to redesign and change them.</description></item><item><title>C++ bindings for libpmemobj (part 7) - synchronization primitives</title><link>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-7-synchronization-primitives/</link><pubDate>Tue, 31 May 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-7-synchronization-primitives/</guid><description>To finish off the C++ bindings to libpmemobj blog marathon, I will introduce to you the synchronization mechanisms we implemented. They are mostly C++11-like implementations of different kinds of mutexes and the condition variable. They satisfy their respective concepts (Mutex, SharedMutex and so on), the difference is that they are based on the persistent memory resident synchronization primitives provided by libpmemobj.
Mutex The pmem::obj::mutex class satisfies the requirements of the Mutex and StandardLayoutType concepts.</description></item><item><title>C++ bindings for libpmemobj (part 6) - transactions</title><link>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-6-transactions/</link><pubDate>Wed, 25 May 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-6-transactions/</guid><description>As I mentioned in my previous blog post, transactions are the heart of libpmemobj. That is why we had to take utmost care while designing their C++ versions, so that they are as easy to use as possible. There are, however, a couple of compromises we had to make due to the inadequacies of the C++11 standard. That is why we encourage using the lambda, until the C++17 standard is more widely implemented.</description></item><item><title>C++ bindings for libpmemobj (part 5) - make_persistent</title><link>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-5-make_persistent/</link><pubDate>Thu, 19 May 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-5-make_persistent/</guid><description>One of the most important features of the C++ bindings to libpmemobj is the persistent_ptr smart pointer template. While using it is fairly straightforward, the allocation and object construction with the use of the C API is hard to get right. So like it&amp;rsquo;s C++ standard&amp;rsquo;s counterparts, it needed an allocation mechanism with appropriate object construction. This is exactly what this post will try to explain.
Transactional allocations Probably the most common usage of the allocating functions is within pmemobj transactions.</description></item><item><title>C++ bindings for libpmemobj (part 4) - pool handle wrapper</title><link>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-4-pool-handle-wrapper/</link><pubDate>Tue, 10 May 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/05/c-bindings-for-libpmemobj-part-4-pool-handle-wrapper/</guid><description>One of the necessary steps in developing the C++ libpmemobj bindings was the introduction of an abstraction of the C pool handle. We decided to do a very simple hierarchy where the pool template inherits from a generic pool_base. This was necessary to be able to have functions/methods which do not depend on the pool&amp;rsquo;s template argument. Please note that this makes both of these handles impossible to keep in persistent memory, due to the presence of a vtable.</description></item><item><title>C++ bindings for libpmemobj (part 0)</title><link>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-0/</link><pubDate>Tue, 12 Jan 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-0/</guid><description>Our goal for the C pmemobj library was to make a fully featured implementation of persistent memory programming model without modifying the compiler. It&amp;rsquo;s meant for authors of very low-level system software and language creators. It&amp;rsquo;s not particularly pretty nor easy to use. The amount of macros, as well as the trickery inside them, might &amp;lsquo;amaze&amp;rsquo; even the biggest preprocessor fans ;)
The natural next step is to leverage the high-level languages features to create a more friendly, less error prone and generally nicer API.</description></item><item><title>C++ bindings for libpmemobj (part 1) - pmem resident variables</title><link>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-1-pmem-resident-variables/</link><pubDate>Tue, 12 Jan 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-1-pmem-resident-variables/</guid><description>One of the biggest hurdles and error prone things about our C API is that the user has to manually keep track of modifications to the persistent memory resident variables while in a transaction. A special semi-transparent template property class has been implemented to automatically add variable modifications to the transaction undo log.
pmem::obj::p Let&amp;rsquo;s start with the vector example from the previous tutorial series. It looked like this:
struct vector { int x; int y; int z; } PMEMoid root = pmemobj_root(pop, sizeof (struct vector)); struct vector *vectorp = pmemobj_direct(root); TX_BEGIN(pop) { pmemobj_tx_add_range(root, 0, sizeof (struct vector)); vectorp-&amp;gt;x = 5; vectorp-&amp;gt;y = 10; vectorp-&amp;gt;z = 15; } TX_END As you can see, the programmer has to remember to call pmemobj_tx_add_range function before any modifications to the memory.</description></item><item><title>C++ bindings for libpmemobj (part 2) - persistent smart pointer</title><link>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-2-persistent-smart-pointer/</link><pubDate>Tue, 12 Jan 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-2-persistent-smart-pointer/</guid><description>In our C API the programmer has to deal with custom pointers represented by the PMEMoid structure. Thanks to some macro magic we made it so that those PMEMoids are somewhat usable. C++ allows us to evolve this concept.
pmem::obj::persistent_ptr Almost everyone who ever touched a C++ code knows the idea behind smart pointers (for example, std::shared_ptr). Our persistent pointer works in the same way. It wraps around a type and provides implementation of operator*, operator-&amp;gt; and operator[].</description></item><item><title>C++ bindings for libpmemobj (part 3) - persistent queue example</title><link>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-3-persistent-queue-example/</link><pubDate>Tue, 12 Jan 2016 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2016/01/c-bindings-for-libpmemobj-part-3-persistent-queue-example/</guid><description>The best way to learn to code is usually by implementing an example. We are going to be creating a linked-list based queue data structure using the the pmem::obj::p and pmem::obj::persistent_ptr classes and libpmemobj C API. But first, a little bit of CS 101 :)
Linked-list queue Queue is a collection of elements with two important operations:
push - adds element to the tail of the structure pop - removes element from the head of the structure This makes the queue a First-In-First-Out (FIFO) data structure.</description></item><item><title>An introduction to pmemobj (part 7) - persistent lists</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-7-persistent-lists/</link><pubDate>Fri, 19 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-7-persistent-lists/</guid><description>The pmemobj library provides non-transactional persistent atomic circular doubly-linked lists (or NTPACDLL for short) API with an interface familiar to anyone who have ever included sys/queue.h header file - it&amp;rsquo;s in fact so similar that I considered not writing this post at all, you can just search the web for CIRCLEQ example.
Fun fact: The exact same list code is used internally by libpmemobj in the transaction undo log implementation.</description></item><item><title>An introduction to pmemobj (part 5) - atomic dynamic memory allocation</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-5-atomic-dynamic-memory-allocation/</link><pubDate>Thu, 18 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-5-atomic-dynamic-memory-allocation/</guid><description>In the previous post I talked about using transactions for allocating new objects, which is fine and is the most similar approach to the standard POSIX way. But it does add an overhead of maintaining an undo log of changes. A more optimal memory management can be achieved using the non-transactional atomic API the pmemobj library provides.
Fail-safe atomic allocations This API is not similar to the APIs most programmers are used to when it comes to handling memory.</description></item><item><title>An introduction to pmemobj (part 6) - threading</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-6-threading/</link><pubDate>Thu, 18 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-6-threading/</guid><description>All of the pmemobj library functions are thread-safe, with following two exceptions: pool management functions (open, close and friends) and pmemobj_root when providing different sizes in different threads - so as long as you are using this function the way it&amp;rsquo;s meant to be used you don&amp;rsquo;t have to worry about it. As for macros - generally only the FOREACH macros are not thread-safe for obvious reasons.
Synchronization If you need to put a lock inside a structure that resides on persistent memory, our library provides pthread-like API for that purpose.</description></item><item><title>An introduction to pmemobj (part 4) - transactional dynamic memory allocation</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-4-transactional-dynamic-memory-allocation/</link><pubDate>Wed, 17 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-4-transactional-dynamic-memory-allocation/</guid><description>This is a topic I intentionally avoided not to introduce too much complexity too fast. The pmemobj library contains an implemented from scratch memory allocator, that was designed with persistent memory in mind. There are two separate APIs: non-transactional and transactional.
Transactional allocations Let&amp;rsquo;s start with a simple snippet of volatile code:
struct rectangle { int a; int b; }; int area_calc(const struct rectangle *rect) { return rect-&amp;gt;a * rect-&amp;gt;b; } .</description></item><item><title>An introduction to pmemobj (part 3) - types</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-3-types/</link><pubDate>Tue, 16 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-3-types/</guid><description>In all of the previous post the code snippets and examples had persistent pointers (PMEMoid) without any type information - they were simple C structures. Very early in the development of the library we discovered that using something like that was extremely error-prone and generally difficult. That&amp;rsquo;s why considerable effort was put into encapsulating the PMEMoids with type-safe container. The end result can be compared with how shared_ptr and the like are done in C++11.</description></item><item><title>An introduction to pmemobj (part 2) - transactions</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-2-transactions/</link><pubDate>Mon, 15 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-2-transactions/</guid><description>By now you should be fairly familiar with the basics persistent memory programming, but to make sure the application is always in a consistent state you had to rely on your own solutions and tricks - like the length of a buffer in the previous example. Now, we will learn a generic solution provided by pmemobj to this type of problems - transactions. For now we will focus on a single-threaded applications with no locking.</description></item><item><title>An introduction to pmemobj (part 1) - accessing the persistent memory</title><link>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-1-accessing-the-persistent-memory/</link><pubDate>Sat, 13 Jun 2015 19:55:17 -0700</pubDate><guid>https://pmem.io/blog/2015/06/an-introduction-to-pmemobj-part-1-accessing-the-persistent-memory/</guid><description>In the previous post, you learned a little bit about the general concept of the persistent memory programming model, now it&amp;rsquo;s time to start the coding ;)
Memory pools If you&amp;rsquo;ve read the overview you know that persistent memory is exposed by the OS as memory-mapped files, we call them pools.
The pmemobj library provides an interface to easily manage those pools, so that you don&amp;rsquo;t have to manually create the files or mmap them.</description></item></channel></rss>