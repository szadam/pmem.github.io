<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Memkind on PMem.io</title><link>https://pmem.io/memkind/</link><description>Recent content in Memkind on PMem.io</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://pmem.io/memkind/index.xml" rel="self" type="application/rss+xml"/><item><title>HBWMALLOC</title><link>https://pmem.io/memkind/manpages/hbwmalloc.3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pmem.io/memkind/manpages/hbwmalloc.3/</guid><description>TABLE OF CONTENTS NAME
SYNOPSIS
DESCRIPTION
RETURN VALUE
ERRORS
NOTES
FILES
ENVIRONMENT
SYSTEM CONFIGURATION
KNOWN ISSUES
COPYRIGHT
SEE ALSO
NAME hbwmalloc - The high bandwidth memory interface
Note: hbwmalloc.h functionality is considered as stable API (STANDARD API).
SYNOPSIS #include &amp;lt;hbwmalloc.h&amp;gt; Link with -lmemkind int hbw_check_available(void); void* hbw_malloc(size_t size); void* hbw_calloc(size_t nmemb, size_t size); void* hbw_realloc (void *ptr, size_t size); void hbw_free(void *ptr); size_t hbw_malloc_usable_size(void *ptr); int hbw_posix_memalign(void **memptr, size_t alignment, size_t size); int hbw_posix_memalign_psize(void **memptr, size_t alignment, size_t size, hbw_pagesize_t pagesize); hbw_policy_t hbw_get_policy(void); int hbw_set_policy(hbw_policy_t mode); int hbw_verify_memory_region(void *addr, size_t size, int flags); DESCRIPTION hbw_check_available() returns zero if high bandwidth memory is available or an error code described in the ERRORS section if not.</description></item><item><title>MEMKIND</title><link>https://pmem.io/memkind/manpages/memkind.3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pmem.io/memkind/manpages/memkind.3/</guid><description>TABLE OF CONTENTS NAME
SYNOPSIS
DESCRIPTION
RETURN VALUE
KINDS
MEMORY TYPES
MEMORY BINDING POLICY
MEMORY FLAGS
MEMORY USAGE POLICY
MEMORY STATISTICS TYPE
MEMORY STATISTICS PRINT OPTIONS
ERRORS
FILES
ENVIRONMENT
SYSTEM CONFIGURATION
STATIC LINKING
KNOWN ISSUES
COPYRIGHT
SEE ALSO
NAME memkind - Heap manager that enables allocations to memory with different properties.
This header expose STANDARD and EXPERIMENTAL API. API Standards are described below in this man page.
SYNOPSIS #include &amp;lt;memkind.h&amp;gt; Link with -lmemkind EXPERIMENTAL API: HEAP MANAGEMENT: int memkind_posix_memalign(memkind_t kind, void **memptr, size_t alignment, size_t size); KIND MANAGEMENT: int memkind_create_kind(memkind_memtype_t memtype_flags, memkind_policy_t policy, memkind_bits_t flags, memkind_t *kind); STANDARD API: ERROR HANDLING: void memkind_error_message(int err, char *msg, size_t size); LIBRARY VERSION: int memkind_get_version(); HEAP MANAGEMENT: void *memkind_malloc(memkind_t kind, size_t size); void *memkind_calloc(memkind_t kind, size_t num, size_t size); void *memkind_realloc(memkind_t kind, void *ptr, size_t size); void memkind_free(memkind_t kind, void *ptr); size_t memkind_malloc_usable_size(memkind_t kind, void *ptr); void *memkind_defrag_reallocate(memkind_t kind, void *ptr); memkind_t memkind_detect_kind(void *ptr); KIND CONFIGURATION MANAGEMENT: struct memkind_config *memkind_config_new(); void memkind_config_delete(struct memkind_config *cfg); void memkind_config_set_path(struct memkind_config *cfg, const char *pmem_dir); void memkind_config_set_size(struct memkind_config *cfg, size_t pmem_size); void memkind_config_set_memory_usage_policy(struct memkind_config *cfg, memkind_mem_usage_policy policy); KIND MANAGEMENT: int memkind_create_fixed(void *addr, size_t size, memkind_t *kind); int memkind_create_pmem(const char *dir, size_t max_size, memkind_t *kind); int memkind_create_pmem_with_config(struct memkind_config *cfg, memkind_t *kind); int memkind_destroy_kind(memkind_t kind); int memkind_check_available(memkind_t kind); ssize_t memkind_get_capacity(memkind_t kind); int memkind_check_dax_path(const char *pmem_dir); STATISTICS: int memkind_update_cached_stats(void); int memkind_get_stat(memkind_t kind, memkind_stat stat, size_t *value); int memkind_stats_print(void (*write_cb) (void *, const char *), void *cbopaque, memkind_stat_print_opt opts); DECORATORS: void memkind_malloc_pre(memkind_t *kind, size_t *size); void memkind_malloc_post(memkind_t kind, size_t size, void **result); void memkind_calloc_pre(memkind_t *kind, size_t *nmemb, size_t *size); void memkind_calloc_post(memkind_t kind, size_t nmemb, size_t size, void **result); void memkind_posix_memalign_pre(memkind_t *kind, void **memptr, size_t *alignment, size_t *size); void memkind_posix_memalign_post(memkind_t kind, void **memptr, size_t alignment, size_t size, int *err); void memkind_realloc_pre(memkind_t *kind, void **ptr, size_t *size); void memkind_realloc_post(memkind_t *kind, void *ptr, size_t size, void **result); void memkind_free_pre(memkind_t *kind, void **ptr); void memkind_free_post(memkind_t kind, void *ptr); ENHANCEMENTS: int memkind_set_bg_threads(bool state); DESCRIPTION memkind_error_message() converts an error number err returned by a member of the memkind interface to an error message msg where the maximum size of the message is passed by the size parameter.</description></item><item><title>MEMKINDALLOCATOR</title><link>https://pmem.io/memkind/manpages/memkindallocator.3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pmem.io/memkind/manpages/memkindallocator.3/</guid><description>TABLE OF CONTENTS NAME
SYNOPSIS
DESCRIPTION
SYSTEM CONFIGURATION
COPYRIGHT
SEE ALSO
NAME libmemkind::static_kind::allocator - The C++ allocator compatible with the C++ standard library allocator concepts
Note: memkind_allocator.h functionality is considered as a stable API (STANDARD API).
SYNOPSIS #include &amp;lt;memkind_allocator.h&amp;gt; Link with -lmemkind libmemkind::static_kind::allocator(libmemkind::kinds kind); template &amp;lt;typename U&amp;gt; libmemkind::static_kind::allocator&amp;lt;T&amp;gt;::allocator(const libmemkind::static_kind::allocator&amp;lt;U&amp;gt;&amp;amp;) noexcept; template &amp;lt;typename U&amp;gt; libmemkind::static_kind::allocator(const allocator&amp;lt;U&amp;gt;&amp;amp;&amp;amp; other) noexcept; libmemkind::static_kind::allocator&amp;lt;T&amp;gt;::~allocator(); T *libmemkind::static_kind::allocator&amp;lt;T&amp;gt;::allocate(std::size_t n) const; void libmemkind::static_kind::allocator&amp;lt;T&amp;gt;::deallocate(T *p, std::size_t n) const; template &amp;lt;class U, class.</description></item></channel></rss>