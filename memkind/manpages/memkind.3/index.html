<!doctype html><html dir=ltr lang=en-us><head><link rel=stylesheet type=text/css href=/css/style.css><meta property="og:title" content="MEMKIND"><meta property="og:description" content="TABLE OF CONTENTS NAME
SYNOPSIS
DESCRIPTION
RETURN VALUE
KINDS
MEMORY TYPES
MEMORY BINDING POLICY
MEMORY FLAGS
MEMORY USAGE POLICY
MEMORY STATISTICS TYPE
MEMORY STATISTICS PRINT OPTIONS
ERRORS
UTILS
ENVIRONMENT
SYSTEM CONFIGURATION
STATIC LINKING
KNOWN ISSUES
COPYRIGHT
SEE ALSO
NAME memkind - A heap manager that enables allocations to memory with different properties.
This header expose a STANDARD and an EXPERIMENTAL API. API Standards are described below in this man page."><meta property="og:type" content="article"><meta property="og:url" content="https://pmem.io/memkind/manpages/memkind.3/"><meta property="article:section" content="memkind"><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>MEMKIND</title><meta name=author content="PMem.io"><meta name=description content="Persistent Memory Development Kit (PMDK) provides support for transactional and atomic operations to keep the data consistent and durable.  PMDK is a collection of open-source libraries and tools that are available for both Linux and Windows OS.  PMDK facilitates persistent memory programming adoption with higher level language support.  Currently, Java, Python, Rust, Go, C and C++ support is fully validated and delivered on Linux and Windows.  This new generation of persistent memory from Intel has introduced a third memory tier (memory persistence, memory tiering).  In addition to memory and storage tiers, the persistent memory tier offers greater capacity than DRAM and significantly faster performance than storage.  Applications can access persistent memory-resident data structures in-place, like they do with traditional memory, eliminating the need to page blocks of data back and forth between memory and storage. PMDK provides a toolkit for memory hierarchy, memory caching, virtual memory and memory tiering.  PMDK-PMEM toolkit provides operational modes in either app direct mode or memory mode. App Direct Mode provides memory persistent, high availability less downtime and significantly faster storage.  In memory mode provides high memory capacity at lower cost and is transparent to applications.  Memory is volatile in memory mode and persistent in App Direct mode"><meta name=robots content="index, follow, archive"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900&display=swap" rel=stylesheet type=text/css><link rel=stylesheet href=/css/bootstrap.css type=text/css><link rel=stylesheet href=/css/style.css type=text/css><link rel=stylesheet href=/css/dark.css type=text/css><link rel=stylesheet href=/css/font-icons.css type=text/css><link rel=stylesheet href=/css/animate.css type=text/css><link rel=stylesheet href=/css/magnific-popup.css type=text/css><link rel=stylesheet href=/css/et-line.css type=text/css><link rel=stylesheet href=/css/components/bs-switches.css type=text/css><link rel=stylesheet href=/css/custom.css type=text/css><meta name=viewport content="initial-scale=1,viewport-fit=cover"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css type=text/css><link rel=stylesheet href="/css/colors.php?color=FE9603" type=text/css><link rel=stylesheet href=/css/template/fonts.css type=text/css><link rel=stylesheet href=/css/template/seo.css type=text/css></head><body class=stretched><div id=wrapper class=clearfix><header id=header class="transparent-header floating-header header-size-md sticky-header"><div id=header-wrap class=dark-mode><div class="container dark-mode"><div class=header-row><div id=logo class=logo_dark><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt=PMem.io></a></div><div id=logo class=logo_light><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo_white.png alt=PMem.io></a></div><div class=header-misc><div id=top-search class=header-misc-icon><a href=# id=top-search-trigger><i class=icon-line-search></i><i class=icon-line-cross></i></a></div><div class=top-links><ul class=top-links-container><li><div id=darkSwitch class="dark-mode header-misc-icon d-md-block"><a href=#><i id=darkSwitchToggle></i></a></div></li></ul></div></div><div id=primary-menu-trigger><svg class="svg-trigger" viewBox="0 0 100 100"><path d="m30 33h40c3.722839.0 7.5 3.126468 7.5 8.578427C77.5 47.030386 74.772971 50 70 50H50"/><path d="m30 50h40"/><path d="m70 67H30s-7.5-.802118-7.5-8.365747C22.5 51.070624 30 50 30 50h20"/></svg></div><nav class="primary-menu with-arrows"><ul class=menu-container><li class="menu-item mega-menu"><div class=menu-link><div><a href=/developer-hub>Developer Hub</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>For Developers</p><p>Everything you need to know about Persistent Memory.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/getting-started-guide><p>Get started <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmdk><p>PMDK <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/repoindex><p>PMem Repositories <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemkv><p>PMemKV <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/pmemstream><p>PMemStream <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/memkind><p>Memkind <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/miniasync><p>MiniAsync <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://tieredmemdb.github.io/><p>TieredMemDB <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/learn>Learn</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Access our Documentation</p><p>Learn more about Persistent Memory features and capabilities.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/books><p>Books <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/persistent-memory/><p>Docs <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/glossary><p>Glossary <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ipmctl-user-guide/><p>ipmctl User Guide <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://docs.pmem.io/ndctl-user-guide/><p>ndctl User Guide <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/faq><p>FAQ <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/knowledgebase><p>Knowledge base <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/tutorials><p>Tutorials <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/videos><p>Videos <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/webinars><p>Webinars <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class="menu-item mega-menu"><div class=menu-link><div><a href=/community>Community</a></div></div><div class="mega-menu-content mega-menu-style-2 px-0"><div class="container dark-mode"><div class=row><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class=fbox-content><p class=fw-bold>Get Connected</p><p>Join an ever-growing community of PMDK-PMEM developers online or in person.</p></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/events><p>Events <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://groups.google.com/group/pmem><p>Forum <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=https://pmem-io.slack.com/join/shared_invite/enQtNzU4MzQ2Mzk3MDQwLWQ1YThmODVmMGFkZWI0YTdhODg4ODVhODdhYjg3NmE4N2ViZGI5NTRmZTBiNDYyOGJjYTIyNmZjYzQxODcwNDg#/shared-invite/email><p>Slack channel <i class=icon-angle-right></i></p></a></div></div></div><div class="mega-menu-column sub-menu-container col-lg-4 border-bottom py-4"><div class=feature-box><div class="fbox-content h-bg-light"><a href=/announcements><p>Announcements <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/blog/2021/10/how-to-contribute-to-pmem.io/><p>Contribute <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#newsletter><p>Newsletter <i class=icon-angle-right></i></p></a></div><div class="fbox-content h-bg-light"><a href=/community/#social-media><p>Social Media <i class=icon-angle-right></i></p></a></div></div></div></div></div></div></li><li class=menu-item><a class=menu-link href=https://pmem.io/solutions><div>Solutions</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/blog><div>Blog</div></a></li><li class=menu-item><a class=menu-link href=https://pmem.io/about><div>About</div></a></li></ul></nav><form class=top-search-form method=get><input id=bcs-searchbox aria-label="Search input" type=text name=q class="form-control bcs-searchbox pt-4" placeholder="Type & Hit Enter.." autocomplete=off></form></div></div></div><div class="header-wrap-clone dark-mode"></div></header><div id=customSearch><div id=bcs_js_snippet></div></div><section id=page-title class="page-title-parallax page-title-center page-title-dark include-header skrollable skrollable-between" style="background-image:url('');background-size:cover;padding:120px 0;margin-top:-157.05px"><div class="container clearfix mt-4"><div class="slider-title text-light"><h2 style=color:#fff></h2></div></div></section><div class="section m-0 bg-transparent library-section dark-mode"><div class=container><div class="row justify-content-between"><div class="col mt-0 lib-content"><h1 id=table-of-contents>TABLE OF CONTENTS</h1><p><a href=#name><strong>NAME</strong></a><br><a href=#synopsis><strong>SYNOPSIS</strong></a><br><a href=#description><strong>DESCRIPTION</strong></a><br><a href=#return-value><strong>RETURN VALUE</strong></a><br><a href=#kinds><strong>KINDS</strong></a><br><a href=#memory-type><strong>MEMORY TYPES</strong></a><br><a href=#memory-binding-policy><strong>MEMORY BINDING POLICY</strong></a><br><a href=#memory-flags><strong>MEMORY FLAGS</strong></a><br><a href=#memory-usage-policy><strong>MEMORY USAGE POLICY</strong></a><br><a href=#memory-statistics-type><strong>MEMORY STATISTICS TYPE</strong></a><br><a href=#memory-statistics-print-options><strong>MEMORY STATISTICS PRINT OPTIONS</strong></a><br><a href=#errors><strong>ERRORS</strong></a><br><a href=#utils><strong>UTILS</strong></a><br><a href=#environment><strong>ENVIRONMENT</strong></a><br><a href=#system-configuration><strong>SYSTEM CONFIGURATION</strong></a><br><a href=#static-links><strong>STATIC LINKING</strong></a><br><a href=#known-issues><strong>KNOWN ISSUES</strong></a><br><a href=#copyright><strong>COPYRIGHT</strong></a><br><a href=#see-also><strong>SEE ALSO</strong></a></p><h1 id=name>NAME</h1><p><strong>memkind</strong> - A heap manager that enables allocations to memory with
different properties.</p><p>This header expose a STANDARD and an EXPERIMENTAL API. API Standards
are described below in this man page.</p><h1 id=synopsis>SYNOPSIS</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;memkind.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>Link with <span style=color:#f92672>-</span>lmemkind
</span></span></code></pre></div><p>EXPERIMENTAL API:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>HEAP MANAGEMENT:
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> memkind_posix_memalign(memkind_t kind, <span style=color:#66d9ef>void</span> <span style=color:#f92672>**</span>memptr, size_t alignment, size_t size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>KIND MANAGEMENT:
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> memkind_create_kind(memkind_memtype_t memtype_flags, memkind_policy_t policy, memkind_bits_t flags, memkind_t <span style=color:#f92672>*</span>kind);
</span></span></code></pre></div><p>STANDARD API:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>ERROR HANDLING:
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> memkind_error_message(<span style=color:#66d9ef>int</span> err, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>msg, size_t size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>LIBRARY VERSION:
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> memkind_get_version();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>HEAP MANAGEMENT:
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>memkind_malloc(memkind_t kind, size_t size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>memkind_calloc</span>(memkind_t kind, size_t num, size_t size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>memkind_realloc</span>(memkind_t kind, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr, size_t size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_free</span>(memkind_t kind, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr);
</span></span><span style=display:flex><span>size_t <span style=color:#a6e22e>memkind_malloc_usable_size</span>(memkind_t kind, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>memkind_defrag_reallocate</span>(memkind_t kind, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr);
</span></span><span style=display:flex><span>memkind_t <span style=color:#a6e22e>memkind_detect_kind</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>KIND CONFIGURATION MANAGEMENT:
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> memkind_config <span style=color:#f92672>*</span>memkind_config_new();
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_config_delete</span>(<span style=color:#66d9ef>struct</span> memkind_config <span style=color:#f92672>*</span>cfg);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_config_set_path</span>(<span style=color:#66d9ef>struct</span> memkind_config <span style=color:#f92672>*</span>cfg, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>pmem_dir);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_config_set_size</span>(<span style=color:#66d9ef>struct</span> memkind_config <span style=color:#f92672>*</span>cfg, size_t pmem_size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_config_set_memory_usage_policy</span>(<span style=color:#66d9ef>struct</span> memkind_config <span style=color:#f92672>*</span>cfg, memkind_mem_usage_policy policy);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>KIND MANAGEMENT:
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> memkind_create_fixed(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>addr, size_t size, memkind_t <span style=color:#f92672>*</span>kind);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>memkind_create_pmem</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>dir, size_t max_size, memkind_t <span style=color:#f92672>*</span>kind);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>memkind_create_pmem_with_config</span>(<span style=color:#66d9ef>struct</span> memkind_config <span style=color:#f92672>*</span>cfg, memkind_t <span style=color:#f92672>*</span>kind);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>memkind_destroy_kind</span>(memkind_t kind);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>memkind_check_available</span>(memkind_t kind);
</span></span><span style=display:flex><span>ssize_t <span style=color:#a6e22e>memkind_get_capacity</span>(memkind_t kind);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>memkind_check_dax_path</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>pmem_dir);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>STATISTICS:
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> memkind_update_cached_stats(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>memkind_get_stat</span>(memkind_t kind, memkind_stat stat, size_t <span style=color:#f92672>*</span>value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>memkind_stats_print</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>write_cb) (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>), <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>cbopaque, memkind_stat_print_opt opts);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DECORATORS:
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> memkind_malloc_pre(memkind_t <span style=color:#f92672>*</span>kind, size_t <span style=color:#f92672>*</span>size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_malloc_post</span>(memkind_t kind, size_t size, <span style=color:#66d9ef>void</span> <span style=color:#f92672>**</span>result);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_calloc_pre</span>(memkind_t <span style=color:#f92672>*</span>kind, size_t <span style=color:#f92672>*</span>nmemb, size_t <span style=color:#f92672>*</span>size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_calloc_post</span>(memkind_t kind, size_t nmemb, size_t size, <span style=color:#66d9ef>void</span> <span style=color:#f92672>**</span>result);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_posix_memalign_pre</span>(memkind_t <span style=color:#f92672>*</span>kind, <span style=color:#66d9ef>void</span> <span style=color:#f92672>**</span>memptr, size_t <span style=color:#f92672>*</span>alignment, size_t <span style=color:#f92672>*</span>size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_posix_memalign_post</span>(memkind_t kind, <span style=color:#66d9ef>void</span> <span style=color:#f92672>**</span>memptr, size_t alignment, size_t size, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>err);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_realloc_pre</span>(memkind_t <span style=color:#f92672>*</span>kind, <span style=color:#66d9ef>void</span> <span style=color:#f92672>**</span>ptr, size_t <span style=color:#f92672>*</span>size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_realloc_post</span>(memkind_t <span style=color:#f92672>*</span>kind, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr, size_t size, <span style=color:#66d9ef>void</span> <span style=color:#f92672>**</span>result);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_free_pre</span>(memkind_t <span style=color:#f92672>*</span>kind, <span style=color:#66d9ef>void</span> <span style=color:#f92672>**</span>ptr);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>memkind_free_post</span>(memkind_t kind, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ENHANCEMENTS:
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> memkind_set_bg_threads(<span style=color:#66d9ef>bool</span> state);
</span></span></code></pre></div><h1 id=description>DESCRIPTION</h1><dl><dt><code>memkind_error_message()</code></dt><dd>converts an error number err returned by a member of the memkind interface
to an error message <em>msg</em> where the maximum size of the message is passed by the
<em>size</em> parameter.</dd><dt>HEAP MANAGEMENT:</dt><dd>The functions described in this section define a heap manager with an interface
modeled on the ISO C standard API’s, except that the user must specify the kind
of memory with the first argument to each function. See the <a href=#kinds><strong>KINDS</strong></a>
section below for a full description of the implemented kinds. For the file-backed
kind of memory see <code>memkind_create_pmem()</code> or <code>memkind_create_pmem_with_config()</code>.
For the memory kind created on user-specified area, please check <code>memkind_create_fixed()</code>.</dd><dt><code>memkind_malloc()</code></dt><dd>allocates <em>size</em> bytes of uninitialized memory of the specified <em>kind</em>. The allocated
space is suitably aligned (after possible pointer coercion) for storage of any type of
object. If <em>size</em> is 0, then <code>memkind_malloc()</code> returns <em>NULL</em>.</dd><dt><code>memkind_calloc()</code></dt><dd>allocates space for <em>num</em> objects each <em>size</em> bytes in length in memory of the
specified <em>kind</em>. The result is identical to calling <code>memkind_malloc()</code> with an argument
of <em>num</em> * <em>size</em>, with the exception that the allocated memory is explicitly initialized
to zero bytes. If <em>num</em> or <em>size</em> is 0, then <code>memkind_calloc()</code> returns <em>NULL</em>.</dd><dt><code>memkind_realloc()</code></dt><dd>changes the size of the previously allocated memory referenced by <em>ptr</em> to <em>size</em> bytes
of the specified <em>kind</em>. The contents of the memory remain unchanged up to the lesser
of the new and old sizes. If the new size is larger, the contents of the newly allocated
portion of the memory are undefined. Upon success, the memory referenced by <em>ptr</em> is
freed and a pointer to the newly allocated memory is returned.
<strong>Note:</strong> <code>memkind_realloc()</code> may move the memory allocation, resulting in a different
return value than <em>ptr</em>.</dd></dl><p>If <em>ptr</em> is <em>NULL</em>, the <code>memkind_realloc()</code> function behaves identically to
<code>memkind_malloc()</code> for the specified size. If <em>size</em> is equal to zero, and
<em>ptr</em> is not <em>NULL</em>, then the call is equivalent to <code>memkind_free(kind, ptr)</code>
and <em>NULL</em> is returned. The address <em>ptr</em>, if not <em>NULL</em>, must have been returned
by a previous call to <code>memkind_malloc()</code>, <code>memkind_calloc()</code>, <code>memkind_realloc()</code>,
<code>memkind_defrag_reallocate()</code> or <code>memkind_posix_memalign()</code> with the same <em>kind</em>
as specified to the call to <code>memkind_realloc()</code>. Otherwise, if <code>memkind_free(kind, ptr)</code>
was called before, undefined behavior occurs. In cases where the kind is unknown in the
context of the call to <code>memkind_realloc()</code> <em>NULL</em> can be given as the <em>kind</em> specified
to <code>memkind_realloc()</code>, but this will require an internal look up for a correct kind.
<strong>Note:</strong> The look up for <em>kind</em> could result in a serious performance penalty, which
can be avoided by specifying a correct <em>kind</em>. If <em>kind</em> is <em>NULL</em> and <em>ptr</em> is <em>NULL</em>,
then <code>memkind_realloc()</code> returns <em>NULL</em> and sets <em>errno</em> to <strong>EINVAL</strong>.</p><dl><dt><code>memkind_posix_memalign()</code></dt><dd>allocates <em>size</em> bytes of memory of a specified <em>kind</em> such that the allocation’s
base address is an even multiple of <em>alignment</em>, and returns the allocation in the value
pointed to by <em>memptr</em>. The requested <em>alignment</em> must be a power of 2 at least as large
as <em>sizeof(void</em>)*. If <em>size</em> is 0, then <code>memkind_posix_memalign()</code> returns 0, with a
<em>NULL</em> returned in <em>memptr</em>.</dd><dt><code>memkind_malloc_usable_size()</code></dt><dd>function provides the same semantics as <code>malloc_usable_size(3)</code>, but operates
on the specified <em>kind</em>.
<strong>NOTE:</strong> In cases where the kind is unknown in the context of the call to
<code>memkind_malloc_usable_size()</code> <em>NULL</em> can be given as the <em>kind</em> specified to
<code>memkind_malloc_usable_size()</code>, but this could require an internal look up for
correct kind. <code>memkind_malloc_usable_size()</code> is supported by TBB heap manager
described in the <a href=#environment>ENVIRONMENT</a> section since Intel TBB 2019 Update 4.</dd><dt><code>memkind_defrag_reallocate()</code></dt><dd>reallocates the object conditionally inside the specific <em>kind</em>. The function
determines if it’s worthwhile to move allocation to the reduce degree of external
fragmentation of the heap. In case of failure function returns <em>NULL</em>, otherwise
function returns a pointer to reallocated memory and memory referenced by <em>ptr</em>
was released and should not be accessed. If <em>ptr</em> is <em>NULL</em>, then
<code>memkind_defrag_reallocate()</code> returns <em>NULL</em>. In cases where the <em>kind</em> is unknown
in the context of the call to <code>memkind_defrag_reallocate()</code> <em>NULL</em> can be given
as the <em>kind</em> specified to <code>memkind_defrag_reallocate()</code>, but this will require
an internal look up for the correct <em>kind</em>.
<strong>Note:</strong> The look up for <em>kind</em> could result in a serious performance penalty,
which can be avoided by specifying a correct <em>kind</em>.</dd><dt><code>memkind_detect_kind()</code></dt><dd>returns the kind associated with allocated memory referenced by <em>ptr</em>.
This pointer must have been returned by a previous call to <code>memkind_malloc()</code>,
memkind_calloc(), <code>memkind_realloc()</code>, memkind_defrag_reallocate() or
<code>memkind_posix_memalign()</code>. If <em>ptr</em> is <em>NULL</em>, then <code>memkind_detect_kind()</code>
returns <em>NULL</em>.
<strong>Note:</strong> This function has non-trivial performance overhead.</dd><dt><code>memkind_free()</code></dt><dd>causes the allocated memory referenced by <em>ptr</em> to be made available for
future allocations. This pointer must have been returned by a previous call to
<code>memkind_malloc()</code>, <code>memkind_calloc()</code>, <code>memkind_realloc()</code>,
<code>memkind_defrag_reallocate()</code> or <code>memkind_posix_memalign()</code>. Otherwise, if
<code>memkind_free(*kind*, *ptr*)</code> has already been called before, undefined behavior
occurs. If <em>ptr</em> is <em>NULL</em>, no operation is performed. In cases where the kind
is unknown in the context of the call to <code>memkind_free()</code> <em>NULL</em> can be given
as the <em>kind</em> specified to <code>memkind_free()</code>, but this will require an internal
look up for correct kind. Note: The look up for <em>kind</em> could result in a serious
performance penalty, which can be avoided by specifying a correct <em>kind</em>.</dd></dl><h4 id=kind-configuration-management>KIND CONFIGURATION MANAGEMENT</h4><p>The functions described in this section define a way to create, delete and update
kind specific configuration. Except of <code>memkind_config_new()</code>, user must specify
the memkind configuration with the first argument to each function. API described
here is most useful with file-backed kind of memory, e.g.
<code>memkind_create_pmem_with_config()</code> method.</p><dl><dt><code>memkind_config_new()</code></dt><dd>creates the memkind configuration.</dd><dt><code>memkind_config_delete()</code></dt><dd>deletes previously created memkind configuration, which must have been
returned by a previous call to <code>memkind_config_new()</code>.</dd><dt><code>memkind_config_set_path()</code></dt><dd>updates the memkind <em>pmem_dir</em> configuration parameter, which specifies
the directory path, where file-backed kind of memory will be created.
<strong>Note:</strong> This function does not validate that <em>pmem_dir</em> specifies a valid path.</dd><dt><code>memkind_config_set_size()</code></dt><dd>updates the memkind <em>pmem_size</em> configuration parameter, which allows to limit
the file-backed kind memory partition.
<strong>Note:</strong> This function does not validate that <em>pmem_size</em> is in valid range.</dd><dt><code>memkind_config_set_memory_usage_policy()</code></dt><dd>updates the memkind <em>policy</em> configuration parameter, which allows to tune up
memory utilization. The user should set the value based on the characteristics of
the application that is using the library (e.g. prioritize memory usage, CPU utilization),
for more details about <em>policy</em> see the <a href=#memory-usage-policy>MEMORY USAGE POLICY</a>
section below.
<strong>Note:</strong> This function does not validate that <em>policy</em> is in valid range.</dd><dt>KIND MANAGEMENT:</dt><dd>There are built-in kinds that are always available and these are enumerated in
the <a href=#kinds>KINDS</a> section. The user can also create their own kinds of memory.
This section describes the API’s that enable the tracking of the different kinds
of memory and determining their properties.</dd><dt><code>memkind_create_fixed()</code></dt><dd>is a function used to create a kind under user-specified area of memory.
The memory can be allocated in any possible way, e.g. it might be a static array
or an mmapped area. User can specify any properties using functions such as mbind.
User is also responsible for de-allocation of memory after the kind destruction.
The memory area must remain valid until fixed_kind is destroyed. The area starts
at address <em>addr</em> and has size <em>size</em>. When heap manager runs out of memory
(located under user-specified area), a call to <strong>memkind_malloc()</strong> returns
<em>NULL</em> and <strong>errno</strong> is set to <strong>ENOMEM</strong>.</dd><dt><code>memkind_create_pmem()</code></dt><dd>is a convenient function used to create a file-backed kind of memory.
It allocates a temporary file in the given directory <em>dir</em>. The file is
created in a fashion similar to <strong>tmpfile(3)</strong>, so that the file name does
not appear when the directory is listed and the space is automatically
freed when the program terminates. The file is truncated to a size of
<em>max_size</em> bytes and the resulting space is memory-mapped.
Note that the actual file system space is not allocated immediately,
but only on a call to <code>memkind_pmem_mmap()</code> (see memkind_pmem(3)). This
allows to create a pmem memkind of a pretty large size without the need
to reserve in advance the corresponding file system space for the entire
heap. If the value of <em>max_size</em> equals 0, pmem memkind is only limited
by the capacity of the file system mounted under <em>dir</em> argument. The minimum
<em>max_size</em> value which allows to limit the size of kind by the library is
defined as <strong>MEMKIND_PMEM_MIN_SIZE</strong>. Calling <code>memkind_create_pmem()</code>
with a size smaller than that and different than 0 will return an error.
The maximum allowed size is not limited by <strong>memkind</strong>, but by the file
system specified by the <em>dir</em> argument. The <em>max_size</em> passed in is the
raw size of the memory pool and <strong>jemalloc</strong> will use some of that space
for its own metadata. Returns zero if the pmem memkind is created successfully
or an error code from the <a href=#errors>ERRORS</a> section if not.</dd><dt><code>memkind_create_pmem_with_config()</code></dt><dd>is a second function used to create a file-backed kind of memory.
Function behaves similar to <code>memkind_create_pmem()</code> but instead of passing
<em>dir</em> and <em>max_size</em> arguments, it uses <em>config</em> param to specify
characteristics of created file-backed kind of memory
(see <a href=#kind-configuration-managment><strong>KIND CONFIGURATION MANAGEMENT</strong></a> section).</dd><dt><code>memkind_create_kind()</code></dt><dd>creates kind that allocates memory with specific memory type, memory
binding policy and flags (see <a href=#memory-flags>MEMORY FLAGS</a> section).
The <em>memtype_flags</em> (see <a href=#memory-types>MEMORY TYPES</a> section) determine
memory types to allocate, <em>policy</em> argument is policy for specifying page
binding to memory types selected by <em>memtype_flags</em>. Returns zero if the
specified kind is created successfully or an error code from the <a href=#errors>ERRORS</a>
section if not.</dd><dt><code>memkind_destroy_kind()</code></dt><dd>destroys previously created kind object, which must have been returned by
a previous call to <code>memkind_create_pmem()</code>, <code>memkind_create_pmem_with_config()</code>
or <code>memkind_create_kind()</code>. Otherwise, or if <code>*memkind_destroy_kind(kind)*</code>
has already been called before, undefined behavior occurs. Note that, when
the kind was returned by <code>memkind_create_kind()</code> all allocated memory must be
freed before kind is destroyed, otherwise this will cause memory leak. When the
kind was returned by <code>memkind_create_pmem()</code> or <code>memkind_create_pmem_with_config()</code>
all allocated memory will be freed after kind will be destroyed.</dd><dt><code>memkind_check_available()</code></dt><dd>returns zero if the specified <em>kind</em> is available or an error code from the
<a href=#errors>ERRORS</a> section if it is not.</dd><dt><code>memkind_get_capacity()</code></dt><dd>returns memory capacity of nodes available to a given kind (file size or
filesystem capacity in case of a file-backed PMEM kind; total area size in the
case of fixed-kind) or -1 in case of an error. Supported kinds are:
<strong>MEMKIND_DEFAULT, MEMKIND_HIGHEST_CAPACITY, MEMKIND_HIGHEST_CAPACITY_LOCAL, MEMKIND_LOWEST_LATENCY_LOCAL, MEMKIND_HIGHEST_BANDWIDTH_LOCAL, MEMKIND_HUGETLB, MEMKIND_INTERLEAVE, MEMKIND_HBW, MEMKIND_HBW_ALL, MEMKIND_HBW_INTERLEAVE, MEMKIND_DAX_KMEM, MEMKIND_DAX_KMEM_ALL, MEMKIND_DAX_KMEM_INTERLEAVE, MEMKIND_REGULAR</strong>,
file-backed PMEM and fixed-kind. <em>kind</em>. For <strong>MEMKIND_HUGETLB</strong> only pages with a
default size of 2MB are supported.</dd><dt><code>memkind_check_dax_path()</code></dt><dd>returns zero if file-backed kind memory is in the specified directory path
<em>pmem_dir</em>. Otherwise, it can be created with the DAX attribute or an error code
from the <a href=#errors>ERRORS</a> section.</dd></dl><p><strong>MEMKIND_PMEM_MIN_SIZE</strong> The minimum size which allows to limit the file-backed
memory partition.</p><dl><dt>STATISTICS:</dt><dd>The functions described in this section define a way to get specific memory
allocation statistics.</dd><dt><code>memkind_update_cached_stats()</code></dt><dd>is used to force an update of cached dynamic allocator statistics. Statistics
are not updated real-time by memkind library and this method allows to force its
update.</dd><dt><code>memkind_get_stat()</code></dt><dd>retrieves statistic of the specified type and returns it in <em>value</em>. Measured
statistic applies to the specific <em>kind</em>, when <em>NULL</em> is given as <em>kind</em> then
statistic applies to memory used by the whole memkind library.
<strong>Note:</strong> You need to call <code>memkind_update_cached_stats()</code> before calling
<code>memkind_get_stat()</code> because statistics are cached by the memkind library.</dd><dt><code>memkind_stats_print()</code></dt><dd>prints summary statistics. This function wraps the jemalloc’s function
<code>je_malloc_stats_print()</code>. Uses *write_cb *function to print the output.
While providing a custom writer function, use <code>syscall(2)</code> rather than <code>write(2)</code>.
Pass <em>NULL</em> in order to use the default <em>write_cb</em> function which prints
the output to the stderr. Use <em>cbopaque</em> parameter in order to pass some data to
your <em>write_cb</em> function. Pass additional options using <em>opts</em>. For more details
on opts see the <a href=#memory-statistics-print-options>MEMORY STATISTICS PRINT OPTIONS</a>
section below. Returns MEMKIND_ERROR_INVALID when failed to parse an options string,
MEMKIND_SUCCESS on success.</dd><dt>DECORATORS:</dt><dd>The memkind library enables the user to define decorator functions that can be
called before and after each memkind heap management API. The decorators that are
called at the beginning of the function end are named after that function with
<em>_pre</em> appended to the name and those that are called at the end of the function
are named after that function with <em>_post</em> appended to the name. These are weak
symbols and if they are not present at link time they are not called. The memkind
library does not define these symbols which are reserved for user definition. These
decorators can be used to track calls to the heap management interface or to modify
parameters. The decorators that are called at the beginning of the allocator pass
all inputs by reference and the decorators that are called at the end of the allocator
pass the output by reference. This enables the modification of the input and output
of each heap management function by the decorators.</dd></dl><p><strong>ENHANCEMENTS:</strong></p><dl><dt><code>memkind_set_bg_threads()</code></dt><dd>enables/disables internal background worker threads in jemalloc.</dd><dt>LIBRARY VERSION:</dt><dd>The memkind library version scheme consist major, minor and patch numbers
separated by dot. Combining those numbers, we got the following representation:</dd></dl><p>major.minor.patch, where:</p><ul><li>major number is incremented whenever the API is changed (loss of
backward compatibility),</li><li>minor number is incremented whenever additional extensions are introduced
or behavior has been changed,</li><li>patch number is incremented whenever small bug fixes are added.</li></ul><p>memkind library provide numeric representation of the version by exposing
the following API:</p><dl><dt><code>memkind_get_version()</code></dt><dd>returns version number represented by a single integer number, obtained from the formula:<br>major * 1000000 + minor * 1000 + patch</dd></dl><p><strong>Note:</strong> major &lt; 1 means an unstable API.</p><p>API standards:</p><ul><li>STANDARD API, the API is considered as stable</li><li>NON-STANDARD API, the API is considered as stable, however this is not a standard way
to use memkind</li><li>EXPERIMENTAL API, the API is considered as unstable and the subject to change</li></ul><h1 id=return-value>RETURN VALUE</h1><p><code>memkind_calloc()</code>, <code>memkind_malloc()</code>, <code>memkind_realloc()</code> and <code>memkind_defrag_reallocate</code>()
returns the pointer to the allocated memory or <em>NULL</em> if the request fails.
<code>memkind_malloc_usable_size()</code> returns the number of usable bytes in the block of
allocated memory pointed to by ptr, a pointer to a block of memory allocated by
<code>memkind_malloc()</code> or a related function. If <em>ptr</em> is <em>NULL</em>, 0 is returned.
<code>memkind_free()</code> and <code>memkind_error_message()</code> do not have return values. All other
memkind API’s return 0 upon success and an error code defined in the <a href=#errors>ERRORS</a>
section upon failure. The memkind library avoids setting <em>errno</em> directly, but calls
to underlying libraries and system calls may set <em>errno</em> (e.g. <code>memkind_create_pmem()</code>).</p><h1 id=kinds>KINDS</h1><p><strong>The available kinds of memory:</strong></p><dl><dt>MEMKIND_DEFAULT</dt><dd>Default allocation using standard memory and default page size.</dd><dt>MEMKIND_HIGHEST_CAPACITY</dt><dd>Allocate from a NUMA node(s) that has the highest capacity among all nodes
in the system.</dd><dt>MEMKIND_HIGHEST_CAPACITY_PREFERRED</dt><dd>Same as <strong>MEMKIND_HIGHEST_CAPACITY</strong> except that if there is not enough memory
in the NUMA node that has the highest capacity in the local domain to satisfy the
request, the allocation will fall back on other memory NUMA nodes.
<strong>Note:</strong> For this kind, the allocation will not succeed if there are two or
more NUMA nodes that have the highest capacity.</dd><dt>MEMKIND_HIGHEST_CAPACITY_LOCAL</dt><dd>Allocate from a NUMA node that has the highest capacity among all NUMA Nodes from
the local domain. NUMA Nodes have the same local domain for a set of CPUs associated
with them, e.g. socket or sub-NUMA cluster.
<strong>Note:</strong> If there are multiple NUMA nodes in the same local domain that have the
highest capacity - allocation will be done from a NUMA node with a worse latency
attribute. This kind requires locality information described in the
<a href=#system-configuration>SYSTEM CONFIGURATION</a> section.</dd><dt>MEMKIND_HIGHEST_CAPACITY_LOCAL_PREFERRED</dt><dd>Same as <strong>MEMKIND_HIGHEST_CAPACITY_LOCAL</strong> except that if there is not enough
memory in the NUMA node that has the highest capacity to satisfy the request, the
allocation will fall back on other memory NUMA nodes.</dd><dt>MEMKIND_LOWEST_LATENCY_LOCAL</dt><dd>Allocate from a NUMA node that has the lowest latency among all NUMA Nodes from
the local domain. NUMA Nodes have the same local domain for a set of CPUs
associated with them, e.g. socket or sub-NUMA cluster. Note: If there are
multiple NUMA nodes in the same local domain that have the lowest latency - allocation
will be done from a NUMA node with smaller memory capacity. This kind requires
locality and memory performance characteristics information described in the
<a href=#system-configuration>SYSTEM CONFIGURATION</a> section.</dd><dt>MEMKIND_LOWEST_LATENCY_LOCAL_PREFERRED</dt><dd>Same as <strong>MEMKIND_LOWEST_LATENCY_LOCAL</strong> except that if there is not enough
memory in the NUMA node that has the lowest latency to satisfy the request,
the allocation will fall back on other memory NUMA nodes.</dd><dt>MEMKIND_HIGHEST_BANDWIDTH_LOCAL</dt><dd>Allocate from a NUMA node that has the highest bandwidth among all NUMA Nodes
from the local domain. NUMA Nodes have the same local domain for a set of CPUs
associated with them, e.g. socket or sub-NUMA cluster. Note: If there are multiple
NUMA nodes in the same local domain that have the highest bandwidth - allocation
will be done from a NUMA node with smaller memory capacity. This kind requires
locality and memory performance characteristics information described in the
<a href=#system-configuration>SYSTEM CONFIGURATION</a> section.</dd><dt>MEMKIND_HIGHEST_BANDWIDTH_LOCAL_PREFERRED</dt><dd>Same as <strong>MEMKIND_HIGHEST_BANDWIDTH_LOCAL</strong> except that if there is not
enough memory in the NUMA node that has the highest bandwidth to satisfy
the request, the allocation will fall back on other memory NUMA nodes.</dd><dt>MEMKIND_HUGETLB</dt><dd>Allocate from standard memory using huge pages.
<strong>Note:</strong> This kind requires huge pages configuration described in the
<a href=#system-configuration>SYSTEM CONFIGURATION</a> section.</dd><dt>MEMKIND_GBTLB (DEPRECATED)</dt><dd>Allocate from standard memory using 1GB chunks backed by huge pages.
<strong>Note:</strong> This kind requires huge pages configuration described in
the <a href=#system-configuration>SYSTEM CONFIGURATION</a> section.</dd><dt>MEMKIND_INTERLEAVE</dt><dd>Allocate pages interleaved across all NUMA nodes with transparent
huge pages disabled.</dd><dt>MEMKIND_HBW</dt><dd>Allocate from the closest high bandwidth memory NUMA node(s) at the time of
allocation. If there is not enough high bandwidth memory to satisfy the request
errno is set to <strong>ENOMEM</strong> and the allocated pointer is set to NULL.
<strong>Note:</strong> This kind requires memory performance characteristics information
described in the <a href=#system-configuration>SYSTEM CONFIGURATION</a> section.</dd><dt>MEMKIND_HBW_ALL</dt><dd>Same as <strong>MEMKIND_HBW except</strong> decision regarding closest NUMA node(s) is
postponed until the time of the first write.</dd><dt>MEMKIND_HBW_HUGETLB</dt><dd>Same as <strong>MEMKIND_HBW</strong> except the allocation is backed by huge pages.
<strong>Note:</strong> This kind requires huge pages configuration described in the
<a href=#system-configuration>SYSTEM CONFIGURATION</a> section.</dd><dt>MEMKIND_HBW_ALL_HUGETLB</dt><dd>Combination of <strong>MEMKIND_HBW_ALL</strong> and <strong>MEMKIND_HBW_HUGETLB</strong> properties.
<strong>Note:</strong> This kind requires huge pages configuration described in the
<a href=#system-configuration>SYSTEM CONFIGURATION</a> section.</dd><dt>MEMKIND_HBW_PREFERRED</dt><dd>Same as <strong>MEMKIND_HBW</strong> except that if there is not enough high bandwidth
memory to satisfy the request, the allocation will fall back on standard memory.
<strong>Note:</strong> For this kind, the allocation will not succeed if two or more high
bandwidth memory NUMA nodes are in the same shortest distance to the same CPU
on which process is eligible to run. Check on that eligibility is done upon
starting the application.</dd><dt>MEMKIND_HBW_PREFERRED_HUGETLB</dt><dd>Same as <strong>MEMKIND_HBW_PREFERRED</strong> except the allocation is backed by huge pages.
<strong>Note:</strong> This kind requires huge pages configuration described in the
<a href=#system-configuration>SYSTEM CONFIGURATION</a> section.</dd><dt>MEMKIND_HBW_GBTLB (DEPRECATED)</dt><dd>Same as <strong>MEMKIND_HBW</strong> except the allocation is backed by 1GB chunks of
huge pages. Note that size can take on any value, but full gigabyte pages will
be allocated for each request, so the remainder of the last page will be wasted.
This kind requires huge pages configuration described in the
<a href=#system-configuration>SYSTEM CONFIGURATION</a> section.</dd><dt>MEMKIND_HBW_PREFERRED_GBTLB (DEPRECATED)</dt><dd>Same as <strong>MEMKIND_HBW_GBTLB</strong> except that if there is not enough high bandwidth
memory to satisfy the request, the allocation will fall back on standard memory.
<strong>Note:</strong> This kind requires huge pages configuration described in the
<a href=#system-configuration>SYSTEM CONFIGURATION</a> section. For this kind,
the allocation will not succeed if two or more high bandwidth memory NUMA
nodes are in the same shortest distance to the same CPU on which process
is eligible to run. Check on that eligibility is done upon starting the application.</dd><dt>MEMKIND_HBW_INTERLEAVE</dt><dd>Same as <strong>MEMKIND_HBW</strong> except that the pages that support the allocation are
interleaved across all high bandwidth nodes and transparent huge pages are disabled.</dd><dt>MEMKIND_DAX_KMEM</dt><dd>Allocate from the closest persistent memory NUMA node at the time of allocation.
If there is not enough memory in the closest persistent memory NUMA node to satisfy
the request <em>errno</em> is set to <strong>ENOMEM</strong> and the allocated pointer is set to <em>NULL</em>.</dd><dt>MEMKIND_DAX_KMEM_ALL</dt><dd>Allocate from the closest persistent memory NUMA node available at the time of
allocation. If there is not enough memory on any of persistent memory NUMA nodes to
satisfy the request <em>errno</em> is set to <strong>ENOMEM</strong> and the allocated pointer is set to <em>NULL</em>.</dd><dt>MEMKIND_DAX_KMEM_PREFERRED</dt><dd>Same as <strong>MEMKIND_DAX_KMEM</strong> except that if there is not enough memory in the
closest persistent memory NUMA node to satisfy the request, the allocation will
fall back on other memory NUMA nodes.
<strong>Note:</strong> For this kind, the allocation will not succeed if two or more persistent
memory NUMA nodes are in the same shortest distance to the same CPU on which process
is eligible to run. Check on that eligibility is done upon starting the application.</dd><dt>MEMKIND_DAX_KMEM_INTERLEAVE</dt><dd>Same as <strong>MEMKIND_DAX_KMEM</strong> except that the pages that support the allocation are
interleaved across all persistent memory NUMA nodes.</dd><dt>MEMKIND_REGULAR</dt><dd>Allocate from regular memory using the default page size. Regular means general purpose
memory from the NUMA nodes containing CPUs.</dd></dl><h1 id=memory-types>MEMORY TYPES</h1><p>The available types of memory:</p><dl><dt>MEMKIND_MEMTYPE_DEFAULT</dt><dd>Standard memory, the same as the process uses.</dd><dt>MEMKIND_MEMTYPE_HIGH_BANDWIDTH</dt><dd>High bandwidth memory (HBM). There must be at least two memory types with
different bandwidth to determine which is the HBM.</dd></dl><h1 id=memory-binding-policy>MEMORY BINDING POLICY</h1><p>The available types of memory binding policy:</p><dl><dt>MEMKIND_POLICY_BIND_LOCAL</dt><dd>Allocate local memory. If there is not enough memory to satisfy the request errno
is set to <strong>ENOMEM</strong> and the allocated pointer is set to NULL.</dd><dt>MEMKIND_POLICY_BIND_ALL</dt><dd>Memory locality is ignored. If there is not enough memory to satisfy the request
errno is set to <strong>ENOMEM</strong> and the allocated pointer is set to NULL.</dd><dt>MEMKIND_POLICY_PREFERRED_LOCAL</dt><dd>Allocate preferred memory that is local. If there is not enough preferred memory
to satisfy the request or preferred memory is not available, the allocation will
fall back on any other memory.</dd><dt>MEMKIND_POLICY_INTERLEAVE_LOCAL</dt><dd>Interleave allocation across local memory. For n memory types the allocation will
be interleaved across all of them.</dd><dt>MEMKIND_POLICY_INTERLEAVE_ALL</dt><dd>Interleave allocation. Locality is ignored. For n memory types the allocation
will be interleaved across all of them.</dd><dt>MEMKIND_POLICY_MAX_VALUE</dt><dd>Max policy value.</dd></dl><h1 id=memory-flags>MEMORY FLAGS</h1><p>The available types of memory flags:</p><dl><dt>MEMKIND_MASK_PAGE_SIZE_2MB</dt><dd>Allocation backed by 2MB page size.</dd></dl><h1 id=memory-usage-policy>MEMORY USAGE POLICY</h1><p>The available types of memory statistics:</p><dl><dt>MEMKIND_STAT_TYPE_RESIDENT</dt><dd>Maximum number of bytes in physically resident data pages mapped.</dd><dt>MEMKIND_STAT_TYPE_ACTIVE</dt><dd>Total number of bytes in active pages.</dd><dt>MEMKIND_STAT_TYPE_ALLOCATED</dt><dd>Total number of allocated bytes.</dd></dl><h1 id=memory-statistics-print-options>MEMORY STATISTICS PRINT OPTIONS</h1><p>The available options for printing statistics:</p><dl><dt>MEMKIND_STAT_PRINT_ALL</dt><dd>Print all statistics.</dd><dt>MEMKIND_STAT_PRINT_JSON_FORMAT</dt><dd>Print statistics in JSON format.</dd><dt>MEMKIND_STAT_PRINT_OMIT_GENERAL</dt><dd>Omit general information that never changes during execution.</dd><dt>MEMKIND_STAT_PRINT_OMIT_MERGED_ARENA</dt><dd>Omit merged arena statistics.</dd><dt>MEMKIND_STAT_PRINT_OMIT_DESTROYED_MERGED_ARENA</dt><dd>Omit destroyed merged arena statistics.</dd><dt>MEMKIND_STAT_PRINT_OMIT_PER_ARENA</dt><dd>Omit per arena statistics.</dd><dt>MEMKIND_STAT_PRINT_OMIT_PER_SIZE_CLASS_BINS</dt><dd>Omit per size class statistics for bins.</dd><dt>MEMKIND_STAT_PRINT_OMIT_PER_SIZE_CLASS_LARGE</dt><dd>Omit per size class statistics for large objects.</dd><dt>MEMKIND_STAT_PRINT_OMIT_MUTEX</dt><dd>Omit all mutex statistics.</dd><dt>MEMKIND_STAT_PRINT_OMIT_EXTENT</dt><dd>Omit extent statistics.</dd></dl><h1 id=errors>ERRORS</h1><dl><dt><code>memkind_posix_memalign()</code></dt><dd>returns one of the POSIX standard error codes <strong>EINVAL</strong> or <strong>ENOMEM</strong> as
defined in the &lt;<em>errno.h</em>> if an error occurs (these have positive values).
If the <em>alignment</em> parameter is not a power of two or is not a multiple of
<em>sizeof(void</em>)*, then <strong>EINVAL</strong> is returned. If there is insufficient memory
to satisfy the request then <strong>ENOMEM</strong> is returned.</dd></dl><p>All functions other than <code>memkind_posix_memalign()</code> which have an integer return
type return one of the negative error codes as defined in the &lt;<em>memkind.h</em>> and
described below.</p><dl><dt>MEMKIND_ERROR_UNAVAILABLE</dt><dd>Requested memory kind is not available</dd><dt>MEMKIND_ERROR_MBIND</dt><dd>Call to <code>mbind(2)</code> failed</dd><dt>MEMKIND_ERROR_MMAP</dt><dd>Call to <code>mmap(2)</code> failed</dd><dt>MEMKIND_ERROR_MALLOC</dt><dd>Call to jemalloc’s <code>malloc()</code> failed</dd><dt>MEMKIND_ERROR_ENVIRON</dt><dd>Error parsing environment variable <em>MEMKIND_</em> *</dd><dt>MEMKIND_ERROR_INVALID</dt><dd>Invalid input arguments to memkind routine</dd><dt>MEMKIND_ERROR_TOOMANY</dt><dd>Error trying to initialize more than maximum <strong>MEMKIND_MAX_KIND</strong>
number of kinds</dd><dt>MEMKIND_ERROR_BADOPS</dt><dd>Error memkind operation structure is missing or invalid</dd><dt>MEMKIND_ERROR_HUGETLB</dt><dd>Unable to allocate huge pages</dd><dt>MEMKIND_ERROR_MEMTYPE_NOT_AVAILABLE</dt><dd>Error requested memory type is not available</dd><dt>MEMKIND_ERROR_OPERATION_FAILED</dt><dd>Error memkind operation failed</dd><dt>MEMKIND_ERROR_ARENAS_CREATE</dt><dd>Call to jemalloc’s arenas.create() failed</dd><dt>MEMKIND_ERROR_RUNTIME</dt><dd>Unspecified run-time error</dd></dl><h1 id=utils>UTILS</h1><dl><dt><em>/usr/bin/memkind-hbw-nodes</em></dt><dd>Prints a comma-separated list of high bandwidth nodes.</dd><dt><em>/usr/bin/memkind-auto-dax-kmem-nodes</em></dt><dd>Prints a comma-separated list of persistent memory NUMA nodes, which are
automatically detected.</dd></dl><h1 id=environment>ENVIRONMENT</h1><dl><dt>MEMKIND_HBW_NODES</dt><dd>This environment variable is a comma-separated list of NUMA nodes that are
treated as high bandwidth. Uses the <em>libnuma</em> routine <code>numa_parse_nodestring()</code>
for parsing, so the syntax described in the <strong>numa</strong>(3) man page for this
routine applies: e.g. 1-3,5 is a valid setting.</dd><dt>MEMKIND_HBW_THRESHOLD</dt><dd>This environment variable is bandwidth in MB/s that is the threshold for
identifying high bandwidth memory. The default threshold is 204800 (200 GB/s),
which is used if this variable is not set. When set, it must be greater
than or equal to 0.</dd><dt>MEMKIND_DAX_KMEM_NODES</dt><dd>This environment variable is a comma-separated list of NUMA nodes that are
treated as PMEM memory. Uses the <em>libnuma</em> routine <code>numa_parse_nodestring()</code>
for parsing, so the syntax described in the <strong>numa</strong>(3) man page for this routine
applies: e.g. 1-3,5 is a valid setting.</dd><dt>MEMKIND_ARENA_NUM_PER_KIND</dt><dd>This environment variable allows leveraging internal mechanism of the library
for setting number of arenas per kind. Value should be a positive integer
(not greater than <strong>INT_MAX</strong> defined in the &lt;<em>limits.h</em>>). The user should
set the value based on the characteristics of the application that is using
the library. Higher value can provide better performance in extremely
multithreaded applications at the cost of memory overhead. See section
<strong>IMPLEMENTATION NOTES</strong> of <strong>jemalloc</strong>(3) for more details about arenas.</dd><dt>MEMKIND_HOG_MEMORY</dt><dd>Controls behavior of memkind with regards to returning memory to the
underlying OS. Setting <strong>MEMKIND_HOG_MEMORY</strong> to 1 causes memkind to not
release memory to the OS in anticipation of memory reuse soon. This will
improve latency of ’free’ operations but increase memory usage.
<strong>Note:</strong> For file-backed kind memory will be released to the OS only
after calling <code>memkind_destroy_kind()</code>, not after ’free’ operations.
In context of <strong>MEMKIND_MEM_USAGE_POLICY_CONSERVATIVE</strong> memory usage
policy - it will also impact memory coalescing and results that block
pages will be often reused (better memory usage at the cost of performance).</dd><dt>MEMKIND_DEBUG</dt><dd>Controls logging mechanism in memkind. Setting <strong>MEMKIND_DEBUG</strong> to 1
enables printing messages like errors and general information about the
environment to the stderr.</dd><dt>MEMKIND_BACKGROUND_THREAD_LIMIT</dt><dd>Enable background worker threads. The Value should be in the 0 to the
maximum number of cpus range. Setting <strong>MEMKIND_BACKGROUND_THREAD_LIMIT</strong>
to the specific value will limit the maximum number of background worker
threads to this value. Value 0 means the maximum number of background worker
threads will be limited to the maximum number of cpus.</dd><dt>MEMKIND_HEAP_MANAGER</dt><dd>Controls heap management behavior in the memkind library by switching to one
of the available heap managers.</dd></dl><p>Values:</p><ul><li>JEMALLOC - sets the jemalloc heap manager</li><li>TBB - sets the Intel Threading Building Blocks heap manager. This option requires
installed Intel Threading Building Blocks library.</li></ul><p>If the <strong>MEMKIND_HEAP_MANAGER</strong> is not set then the jemalloc heap manager will
be used by default.</p><h1 id=system-configuration>SYSTEM CONFIGURATION</h1><p>Interfaces for obtaining 2MB (HUGETLB) memory need allocated huge pages in the
kernel’s huge page pool.</p><dl><dt>HUGETLB (huge pages)</dt><dd>Current number of &ldquo;persistent&rdquo; huge pages can be read from the
<em>/proc/sys/vm/nr_hugepages</em> file. Proposed way of setting hugepages is:
<code>sudo sysctl vm.nr_hugepages=&lt;number_of_hugepages></code>. More information
can be found <a href=https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt>here</a></dd></dl><p>Interfaces for obtaining locality information are provided by <em>libhwloc</em> dependency.
Functionality based on locality requires that the memkind library is configured
and built with the support of the <a href=https://www.open-mpi.org/projects/hwloc><em>libhwloc</em></a> :<br><code>./configure --enable-hwloc</code></p><p>Interfaces for obtaining memory performance characteristics information are based
on the <em>HMAT</em> (Heterogeneous Memory Attribute Table)
<a href=https://uefi.org/sites/default/files/resources/ACPI_6_3_final_Jan30.pdf>https://uefi.org/sites/default/files/resources/ACPI_6_3_final_Jan30.pdf</a>
Functionality based on memory performance characteristics requires that
the platform configuration fully supports <em>HMAT</em> and the memkind library
is configured and built with the support of the
<a href=https://www.open-mpi.org/projects/hwloc><em>libhwloc</em></a> :<br><code>./configure --enable-hwloc</code></p><p><strong>Note:</strong> For a given target NUMA Node, the OS exposes only the performance
characteristics of the best performing NUMA node.</p><h1 id=static-linking>STATIC LINKING</h1><p>When linking statically against memkind, <em>libmemkind.a</em> should be used together
with its dependencies <em>libnuma</em> and pthread. Pthread can be linked by adding
<em>/usr/lib64/libpthread.a</em> as a dependency (exact path may vary). Typically
<em>libnuma</em> will need to be compiled from sources to use it as a static dependency.
<em>libnuma</em> can be reached on <a href=https://github.com/numactl/numactl>GitHub</a></p><h1 id=known-issues>KNOWN ISSUES</h1><dl><dt>HUGETLB (huge pages)</dt><dd>There might be some overhead in huge pages consumption caused by heap management.
If your allocation fails because of OOM, please try to allocate extra huge pages
(e.g. 8 huge pages).</dd></dl><h1 id=copyright>COPYRIGHT</h1><p>Copyright (C) 2014 - 2022 Intel Corporation. All rights reserved.</p><h1 id=see-also>SEE ALSO</h1><p><strong>malloc</strong>(3), <strong>malloc_usable_size</strong>(3), <strong>numa</strong>(3), <strong>hwloc</strong>(3), <strong>numactl</strong>(8), <strong>mbind</strong>(2), <strong>mmap</strong>(2), <strong>jemalloc</strong>(3), <strong>memkind_dax_kmem</strong>(3), <strong>memkind_default</strong>(3), <strong>memkind_arena</strong>(3), <strong>memkind_fixed</strong>(3), <strong>memkind_hbw</strong>(3), <strong>memkind_hugetlb</strong>(3), <strong>memkind_pmem</strong>(3), <strong>syscall</strong>(2), <strong>write</strong>(2)</p></div></div><div class=divider></div><p class=text-center><small>The contents of this web site and the associated <a href=https://github.com/memkind>GitHub repositories</a> are BSD-licensed open source.</small></p></div></div><footer id=footer class="border-0 bg-white"><div id=copyrights><div class="container clearfix"><div class="row justify-content-between col-mb-30"><div class="col-12 col-lg-auto text-center text-lg-start"><div id=logo><a href=/ class=standard-logo data-dark-logo=images/logo-dark.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a>
<a href=/ class=retina-logo data-dark-logo=images/logo-dark@2x.png><img src=https://pmem.io/images/pmem_logo.png alt="PMem Logo"></a></div></div><div class="col-12 col-lg-auto text-center text-lg-end"><div class="copyrights-menu copyright-links clearfix text-uppercase"><a href=https://pmem.io/about>about</a>/
<a href=https://pmem.io/blog>blog</a>/
<a href=https://pmem.io/community>community</a>/
<a href=https://pmem.io/cookies.html>Cookies</a>/
<a href=https://pmem.io/developer-hub>developer Hub</a>/
<a href=https://pmem.io/learn>learn</a>/
<a href=https://pmem.io/privacy.html>Privacy</a>/
<a href=https://pmem.io/solutions>solutions</a>/
<a href=https://pmem.io/terms.html>Terms</a></div><div class="col-lg-auto text-center mt-0"><p>Copyright &copy; 2023 pmem.io</p></div></div></div></div></div></footer></div><div id=gotoTop class=icon-angle-up></div><script src=/js/jquery.js></script>
<script src=/js/plugins.min.js></script>
<script src=/js/custom.js></script>
<script src=/js/darkmode.js></script>
<script src=/js/functions.js></script>
<script type=text/javascript src="https://ui.customsearch.ai/api/ux/rendering-js?customConfig=011a90aa-26ea-46b5-bf60-4b5b407c72c6&market=en-US&version=latest&q="></script></body></html>